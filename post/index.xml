<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on JokenOffline(電子版)</title>
    <link>https://kyumina.github.io/jokenoffline2017/post/index.xml</link>
    <description>Recent content in Posts on JokenOffline(電子版)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 07 Apr 2017 20:31:38 +0900</lastBuildDate>
    <atom:link href="https://kyumina.github.io/jokenoffline2017/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Direct3Dに対するWallHack</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/how_to_wallhack/</link>
      <pubDate>Fri, 07 Apr 2017 20:31:38 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/how_to_wallhack/</guid>
      <description>

&lt;h1 id=&#34;概要&#34;&gt;概要&lt;/h1&gt;

&lt;p&gt;　本記事では、Windows環境で、Direct3Dを採用したアプリケーションに対してMid-Function Hookを行うことにより、簡易的なWallhackを実装する。対象とするアプリケーションはDirect3D9のサンプルとして付属するプログラムで、Wallhackにより特定のオブジェクトのテクスチャを赤色に変更する。なお、一般的なWallhackが搭載する、オブジェクトを最前面に描画する処理については本記事では実装しない。&lt;/p&gt;

&lt;h1 id=&#34;注意&#34;&gt;注意&lt;/h1&gt;

&lt;h2 id=&#34;読者へのお願い&#34;&gt;読者へのお願い&lt;/h2&gt;

&lt;p&gt;　本記事ではゲームの不正行為として使用できる技術について説明するが、法律で許可される範囲で実験するように注意されたい。また、本記事はそのような行為を助長するためでなく、この分野が非常に幅広い技術を応用していることから、スキルアップのための教材として優れていると考えたために記事とした。実際に各自の環境で本記事の内容を試す場合は、自分でビルドしたものなど、必ずWallhackが許可されたアプリケーションに試すこと。&lt;/p&gt;

&lt;h2 id=&#34;本記事の対象者&#34;&gt;本記事の対象者&lt;/h2&gt;

&lt;p&gt;　本記事を読むだけでWallhackについて十分に理解することは難しいかもしれないが、分からない部分はインターネットで調べながら読んでほしい。その上で、次のような方は少し理解しやすいかもしれない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windowsに慣れ親しんでいる&lt;/li&gt;
&lt;li&gt;C, C++がある程度読める（特にポインタの理解）&lt;/li&gt;
&lt;li&gt;アセンブリがある程度読める（Intel x86）&lt;/li&gt;
&lt;li&gt;DLLの用途と原理を知っている&lt;/li&gt;
&lt;li&gt;エンディアンについて知っている&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;原理&#34;&gt;原理&lt;/h1&gt;

&lt;h2 id=&#34;wallhack&#34;&gt;Wallhack&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Wallhack&lt;/strong&gt; とは、3Dゲーム（特にFirst Person Shooting）に対するチート行為の一種である。Wallhackでは一般的に、Direct3DやOpenGLなどのAPIをフックすることにより、プログラムに任意の処理を割り込ませる。それにより、敵キャラクターなどの特定のオブジェクトを常に最前面に描画するなどし、敵の位置を把握しやすいようにできる。また、本記事で実装するように、特定のオブジェクトが目立つようにテクスチャを派手なものに変更することを、カメレオン（Chameleon）から取って &lt;strong&gt;Chams&lt;/strong&gt; と呼ぶ。なお、本記事では先に述べたように後者についてのみ実装する。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/example_of_wallhack.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Wallhackされた3Dのゲームの例&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;Left 4 Dead 2 assistantによるWallhack Modより引用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;仮想関数テーブル&#34;&gt;仮想関数テーブル&lt;/h2&gt;

&lt;p&gt;　C言語などでコンパイルするとき、関数は実行ファイル上で絶対的なアドレスに配置される。一方クラスを使用すると、変数と同じ扱いになるため、メソッドはメモリ上のランダムな位置に展開されることになる。（関数も実行時にはランダムな位置に配置されるが、これは容易に特定できる。）そこでプログラムがメソッドにアクセスするとき、仮想関数テーブル（&lt;strong&gt;vTable&lt;/strong&gt;）と呼ばれる表を参照してメソッドのアドレスを特定する。&lt;/p&gt;

&lt;h2 id=&#34;dllインジェクション&#34;&gt;DLLインジェクション&lt;/h2&gt;

&lt;p&gt;　外部から、あるプロセスの中で特定の処理を割り込ませたいとき、1つの方法として&lt;strong&gt;DLLインジェクション&lt;/strong&gt;と呼ばれる手法がある。これは、任意の処理を実装したDLLを特定のプロセスに読み込ませることにより、そのプロセスの内部で処理を実行する方法である。Windowsの場合、CreateRemoteThreadという関数が用意されており、これは特定のプロセス上で、引数が1つの関数を呼び出すことができるという不思議な関数である。一方LoadLibrary関数は、DLLのパスを引数とする1引数の関数で、その関数を呼び出したプロセスにDLLをロードする。したがって、CreateRemoteThread関数を使い特定のプロセスでLoadLibrary関数を実行させることにより、任意のDLLをロードすることができる。これがWindowsにおける一般的なDLLインジェクションの方法である。&lt;/p&gt;

&lt;h2 id=&#34;フック&#34;&gt;フック&lt;/h2&gt;

&lt;p&gt;　あるプログラムの特定の関数やメソッドの呼出時に任意の動作を割り込ませたいとき、その処理から任意のコードにジャンプするように書き換えることを「&lt;strong&gt;フックする&lt;/strong&gt;」と呼ぶ。特に、処理の途中で自分の用意したコードにジャンプするような機械語を挿入する技術を&lt;strong&gt;detours&lt;/strong&gt;(迂回)などと呼ぶ。例えば以下のような処理があったとする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;function:
76FA13F2: push ebp
76FA13F3: mov ebp, esp
76FA13F5: push esi
76FA13F6: mov esi, [ebp + 8]
76FA13F9: cmp esi, -C
76FA13FC: jnb 76FA45FB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これを次のように変更することで、元のプログラムに影響を与えずに任意のコードへジャンプすることができる。（jmpの設置場所と機械語の命令長に注意してnopなどを配置すること。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;function:
76FA13F2: push ebp
76FA13F3: mov ebp, esp
76FA13F5: push esi
76FA13F6: jmp [hook_function]
76FA13FB: nop
76FA13FC: jnb 76FA45FB
...

hook_function:
06201000: [My Program]
06201XXX: mov esi, [ebp + 8]
06201XXX: cmp esi, -C
06201XXX: jmp 76FA13FC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　このように、処理の途中で任意の処理にジャンプさせるようなフックを&lt;strong&gt;Mid-Function Hook&lt;/strong&gt;と呼ぶ。なお、レジスタを破壊してしまう場合は、hook_functionにpushadやpushfdを利用してスタックに退避しておくと安全である。&lt;/p&gt;

&lt;p&gt;　DLLインジェクションは任意の処理を他プロセスで実行するのに対して、フックは既存の処理が呼び出されたときに任意の処理を割込ませるという違いがある。したがって、フックでは関数やメソッドが呼び出されたときの引数が取得できるという利点もある。&lt;/p&gt;

&lt;h1 id=&#34;前提条件&#34;&gt;前提条件&lt;/h1&gt;

&lt;p&gt;本記事で使用する環境について、特に重要な部分を下の表に示した。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;情報&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;実験環境&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;OS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Windows 10 x86&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;コンパイラ&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Visual C++ 2015&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;エディタ&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Visual Studio 2015&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;使用ライブラリ&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DirectX 3D (June 2010)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;使用ツール&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;うさみみハリケーン、DebugView、IDA Pro&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Wallhack対象&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DirectXのサンプルプログラム&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Visual C++は特にインラインアセンブリに非常に長けており、直感的にアセンブリを書くことができるため、今回のような低レイヤな部分を扱うときには大変便利である。また、今回のプログラムはWindowsのバージョンよりもDirect3Dのバージョンに大きく関わるため、各環境によってプログラムの細かい部分が違ってくることに注意されたい。（本記事のプログラムは上記環境で実装したが、Windows 7 x86でもWallhackに成功した。）&lt;/p&gt;

&lt;h1 id=&#34;endsceneメソッドをフックする&#34;&gt;EndSceneメソッドをフックする&lt;/h1&gt;

&lt;p&gt;Direct3Dでは、レンダリングの終了を知らせるEndSceneメソッドがあり、これは画面を更新するごとに呼び出される。この章では、EndSceneをフックすることで、先に特定の文字列を最前面に描画してから本来のEndScene機能を呼び出すように処理を変更する。&lt;/p&gt;

&lt;h2 id=&#34;デバッグ方法&#34;&gt;デバッグ方法&lt;/h2&gt;

&lt;p&gt;　今回はDLLインジェクションにより外部でコードを実行する。このようなときに簡単にプログラムの状況を確認できるのがOutputDebugString関数である。例えばDWORD型の値を確認する場合、次のようなコードを挿入する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;TCHAR str[64] = TEXT(&amp;quot;&amp;quot;);
  wsprintf(str, TEXT(&amp;quot;0x%x&amp;quot;), value);
  OutputDebugString(str);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これを確認するのがDebugViewというツールである。このツールではOutputDebugStringにより出力された文字列を取得して表示できる。&lt;/p&gt;

&lt;h2 id=&#34;dllインジェクションを試す&#34;&gt;DLLインジェクションを試す&lt;/h2&gt;

&lt;p&gt;　まずは自分でDLLを作り、それを対象のプロセスにロードできるかを確認する。今回はDLLを作るだけで、インジェクションはうさみみハリケーン&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; というツールを使用する。&lt;/p&gt;

&lt;p&gt;　新規DLLプロジェクトの作成方法は各自調べてもらいたいが、Win32プロジェクトにすること、空のプロジェクトにすることだけは注意してほしい。プロジェクトに適当なファイル名でcppファイルを作成する。本記事では全ての処理をこのcppファイルに記述する。以下がDLLインジェクション確認用の最低限のプログラムである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;windows.h&amp;gt;
BOOL WINAPI DllMain(HINSTANCE hModule,
                    DWORD fdwReason,
                    LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        MessageBox(NULL,
                   TEXT(&amp;quot;Injection Test&amp;quot;),
                   TEXT(&amp;quot;Debug&amp;quot;),
                   MB_OK);
    }
    return TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　プログラムについて詳しくは説明しないが、DLLがロードされるとメッセージボックスが表示されるコードである。&lt;/p&gt;

&lt;p&gt;　プロジェクトをビルドするとDLLが出力される。ロード対象のプロセスとうさみみハリケーンを起動し、うさみみハリケーンで対象プロセスにアタッチし、メニューバーの「デバッグ」から「DLLのロードとアンロード」を選ぶ。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/usamimi_dll_load.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;うさみみハリケーン DLLのロードとアンロード&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　DLLパスに先程コンパイルしたDLLを選択し、「ロード実行」ボタンでDLLをロードしてくれる。ロードと同時に、次のようにメッセージボックスが表示されたらDLLインジェクションは成功である。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/dll_injection_test.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;DLLインジェクションにより任意の処理を実行できた&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　またここでは記述していないが、Visual StudioのプロジェクトのプロパティでインクルードディレクトリやライブラリディレクトリにDirect3Dのパスを追加しておく必要がある。先頭に次のライブラリ使用宣言を記述してもエラーにならなければ正しくパスは設定できている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;d3d9.h&amp;gt;
#include &amp;lt;d3dx9.h&amp;gt;
#pragma comment(lib, &amp;quot;d3d9.lib&amp;quot;)
#pragma comment(lib, &amp;quot;d3dx9.lib&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　なお、パスを設定するとき、もしくはプロジェクトをビルドするときに、プロパティとビルドがそれぞれReleaseもしくはDebugで統一されていないとエラーになる。また、本記事では全て32bitを想定しているので、x86用にビルドすること。&lt;/p&gt;

&lt;h2 id=&#34;vtableを探索する&#34;&gt;vTableを探索する&lt;/h2&gt;

&lt;p&gt;　DLLインジェクションが成功したということは、それ以降は通常のプログラム同様に対象プロセスの内部を操作することができる。そこでまず最初に必要なのが、EndSceneのアドレスを持つIDirect3DDevice9クラスのvTableである。vTableさえ手に入れば、vTableからメソッドのアドレスが全て取得できる。残念ながらvTableの場所は分からないため、今回はこれを探索するプログラムを書いた。Direct3Dのライブラリ内にはvTableを参照するコードとして次のような処理が存在する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;...
33C0          : xor eax, eax
C760 XXXXXXXX : mov [esi], d3d9.dll+XXXXXXXX ; vTable
8986 XXXXXXXX : mov [esi+XXXXXXXX], eax
8986 XXXXXXXX : mov [esi+XXXXXXXX], eax
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　C760の後の4バイトがvTableのアドレスである。このような機械語を持つパターンを探索する方法が一般的であるので、本記事でもこのコードを探索した。なお、このコードはd3d9.dllがロードされた先に存在し、そのアドレスはGetModuleHandle関数により分かるので、メモリのごく一部を探索するだけで見つかる。以下にvTableを探索する関数を示す。なお、hD3DはGetModuleHandleにより取得したd3d9.dllのロード先アドレスである。また、変数vTalbeはDWORD型で、グローバル変数として定義している。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;VOID GetVTableAddr(DWORD hD3D)
{
    // モジュールのロード先から探索する
    for (DWORD i = 0; i &amp;lt; 0x128000; i++) {
        BOOL match = *(WORD*)(hD3D + i) == (WORD)0x06C7
            &amp;amp;&amp;amp; *(WORD*)(hD3D + i + 6) == (WORD)0x8689
            &amp;amp;&amp;amp; *(WORD*)(hD3D + i + 12) == (WORD)0x8689;
        if (match) {
            DWORD oldProtection;
            VirtualProtect(&amp;amp;vTable,
                           4,
                           PAGE_EXECUTE_READWRITE,
                           &amp;amp;oldProtection);
            CopyMemory(&amp;amp;vTable, (void*)(hD3D + i + 2), 4);
            VirtualProtect(&amp;amp;vTable,
                           4,
                           oldProtection,
                           &amp;amp;oldProtection);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これによりvTableが取得できるが、テーブルのポインタがどのメソッドを表しているかはIDA Proなどでd3d9.dllを解析することにより容易に分かる。例えば今回フックするEndSceneの場合、IDA ProでEndSceneという名前を調べると、vTable上の関数が並んでいる。（これよりEndSceneはvTable[42]でアクセスできることが分かる。）&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/ida_vtable.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;IDA Proが見つけたvTableの構造&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　また、このような情報はインターネットで検索するとすぐに出てくるが、環境によって大きく異なる場合もあるので、自分の環境でも確認しておくことを推奨する。&lt;/p&gt;

&lt;h2 id=&#34;メソッドをフックする&#34;&gt;メソッドをフックする&lt;/h2&gt;

&lt;p&gt;　vTableが取得できたら、次にメソッドをフックする。今回はEndScene(vTable[42])をフックする。まずはvTable[42]の値をDebugViewなどで調べて、そのアドレスにうさみみハリケーンでアクセスする。うさみみハリケーンには逆アセンブルツールが付いている。メニューバーの「デバッグ」の「選択範囲を逆アセンブル」でEndSceneの処理を見てみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;EndScene:
6A 20       : push 0x20
B8 XXXXXXXX : mov eax, XXXXXXXX
E8 XXXXXXXX : call XXXXXXXX
8B7D 08     : mov edi, [ebp + 0x8]
33F6        : xor esi, esi
85FF        : test edi, edi
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これは環境によって大きく異なるので必ず自分で確認する必要がある。今回はこれを次のように書き換える。なお、dwEndScene_retはこの場合「test edi, edi」のアドレスである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;EndScene:
6A 20       : push 0x20
B8 XXXXXXXX : mov eax, XXXXXXXX
E8 XXXXXXXX : call XXXXXXXX
E9 XXXXXXXX : jmp hook_EndScene
85FF        : test edi, edi
...

hook_EndScene:
;;
;; Put New EndScene Here
;;
8B7D 08     : mov edi, [ebp + 0x8]
33F6        : xor esi, esi
E9 XXXXXXXX : jmp dwEndScene_ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　jmpを入れる場所は必ず最低5バイトは上書きする必要がある。今回はちょうど5バイトを上書きしたが、例えば6バイトを潰す必要がある場合はnopなどで埋めると良い。また、原理で説明したように元の処理を迂回先に記述する必要がある。さらに、今回は必要無いが、jmpを挿入する場所によってはpushadやpushfdなどを使用してレジスタの状態を保存しておかないと、新しいEndSceneでレジスタが破壊されてプロセスがクラッシュする場合もある。&lt;/p&gt;

&lt;p&gt;さて、まずはjmpコードを挿入するプログラムを以下に示す。なお、hookAddrはフックする関数のポインタ、jmpAddrはジャンプ先のアドレス、sizeはjmpで潰す命令のコード長を指定する。また、jmp命令のジャンプ先アドレスは、機械語ではjmp命令からの相対アドレスになることに注意されたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;VOID MakeMFH(PBYTE hookAddr, DWORD jmpAddr, DWORD size)
{
    DWORD oldProtect, relativeAddr;
    VirtualProtect(hookAddr,
                   size,
                   PAGE_EXECUTE_READWRITE,
                   &amp;amp;oldProtect);
    // 相対アドレスに変換
    relativeAddr = (DWORD)(jmpAddr - (DWORD)hookAddr) - 5;
    // E9 XX XX XX XX : jmp [XXXXXXXX]
    *hookAddr = 0xE9;
    *((DWORD *)(hookAddr + 1)) = relativeAddr;
    // NOPで埋める
    for (DWORD x = 0x5; x &amp;lt; size; x++) *(hookAddr + x) = 0x90;
    VirtualProtect(hookAddr,
                   size,
                   oldProtect,
                   &amp;amp;oldProtect);
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　今回は少しでも汎用的にするために、上書きする命令が5バイトでなくても動作するように5バイト目以降はnopで埋めるようにした。
次に、フックによりジャンプする先の処理を以下に示す。「__delcspec(naked)」を記述すると、コンパイラが通常関数の先頭に入れる余計な命令を入れないようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;__declspec(naked) void hook_EndScene()
{
    static LPDIRECT3DDEVICE9 pDevice;
    // pDeviceを取得する
    __asm {
        mov edi, [ebp + 0x8]
        mov pDevice, edi;
    }
    // 用意した処理を呼び出す
    my_EndScene(pDevice);
    // 上書きした命令を実行してから元の場所に戻る
    __asm {
        mov edi, [ebp + 0x8]
        xor esi, esi
        jmp EndScene_ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　このプログラムから分かるように、Visual Studioのインラインアセンブリは非常に直感的で、変数も直接アセンブリに書くことが許される。EndSceneメソッドを持つクラスであるIDirect3DDevice9を指すポインタは、この時[ebp+0x8]に存在する。これについては、同様のコードは調べればいくらでも見つかる上、この引数の場所に関しては私の知る限りx86では環境に依存せずebp+0x8である。(ちなみに第一引数はebp+0xC、第二引数はebp+0x10と続く。)このフックさえ正しく書ければ最大の山は乗り越えたであろう。（多くの場合はここでつまずく。）次の節ではmy_EndSceneについて説明する。&lt;/p&gt;

&lt;h2 id=&#34;任意の文字列を描画する&#34;&gt;任意の文字列を描画する&lt;/h2&gt;

&lt;p&gt;my_EndScene関数では取得したpDeviceを元に、普通のDirect3Dプログラミング同様に様々な処理を実行できる。今回は文字列を描画するので、フォントを生成して文字を書く処理を用意した。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;VOID WINAPI my_EndScene(LPDIRECT3DDEVICE9 pDevice)
{
    LPD3DXFONT pFont;
    D3DXCreateFont(pDevice,
                   18,
                   0,
                   FW_BOLD,
                   1,
                   0,
                   DEFAULT_CHARSET,
                   OUT_DEFAULT_PRECIS,
                   DEFAULT_QUALITY,
                   DEFAULT_PITCH | FF_DONTCARE,
                   TEXT(&amp;quot;Arial&amp;quot;),
                   &amp;amp;pFont);
    // 文字列を描画
    RECT rect;
    SetRect(&amp;amp;rect, 32, 32, 32, 32);
    pFont-&amp;gt;DrawText(NULL,
                    TEXT(&amp;quot;Wallhack is enabled.&amp;quot;),
                    -1,
                    &amp;amp;rect,
                    DT_NOCLIP | DT_LEFT,
                    D3DCOLOR_ARGB(255, 255, 000, 000));
    pFont-&amp;gt;Release();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;組み合わせる&#34;&gt;組み合わせる&lt;/h2&gt;

&lt;p&gt;　ここまでで作成した関数はDllMainからは呼び出さない。新しくスレッドを作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;VOID MyHook()
{
    // d3d9.dllをメモリに展開する
    DWORD hD3D = (DWORD)GetModuleHandle(TEXT(&amp;quot;d3d9.dll&amp;quot;));
    if (hD3D == NULL) return;
    // vTableのアドレスを探索する
    GetVTableAddr(hD3D);
    /*
        EndSceneメソッドの中間にdetourを作成する
            EndScene+0Ch : 8B7D 08 : mov edi, [ebp + 8h]
            EndScene+0Fh : 33f6    : xor esi, esi
            --&amp;gt; jmp [hook_EndScene]
    */
    EndScene_hook = vTable[42] + 0xC;
    EndScene_ret = EndScene_hook + 5;
    MakeMFH((PBYTE)EndScene_hook, (DWORD)hook_EndScene, 3 + 2);
}

BOOL WINAPI DllMain(HINSTANCE hModule,
                    DWORD fdwReason,
                    LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hModule);
        CreateThread(NULL,
                     NULL,
                     (LPTHREAD_START_ROUTINE)MyHook,
                     NULL,
                     NULL,
                     NULL);
    }
    return TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これら全てをまとめたプログラムは次のURLからダウンロードできる。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/qr_code1.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ptr-yudai/jokenoffline/blob/master/wallhack01.cpp&#34;&gt;https://github.com/ptr-yudai/jokenoffline/blob/master/wallhack01.cpp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　早速実行してみよう。対象とするプログラムはDirect3Dのサンプルにある「ShadowMap.exe」である。DLLインジェクションにより作成したDLLをロードさせると、図に示したようにフックが成功していることが確認できる。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/wallhack_test_1.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;EndSceneのフックによる文字列の描画&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　図から分かるように、my_EndSceneが実行されて「Wallhack is enabled.」という文字列が左上に大きく表示されている。&lt;/p&gt;

&lt;h1 id=&#34;wallhackする&#34;&gt;Wallhackする&lt;/h1&gt;

&lt;p&gt;　ここまではEndSceneをフックして、できるだけ簡単にフックが成功していることを確認した。ここからはWallhackの本題である「特定のオブジェクトのテクスチャを目立つ色に変更する」という処理を作る。&lt;/p&gt;

&lt;h2 id=&#34;dipをフックする&#34;&gt;DIPをフックする&lt;/h2&gt;

&lt;p&gt;　DIPとはDrawIndexedPrimitiveメソッドのことで、物体をレンダリングするためのメソッドである。Direct3Dをフックする方法によるWallhackでは必ずといってよいほどDrawIndexedPrimitiveメソッドがフックされるので、DIPという略称がしばしば使われる。&lt;/p&gt;

&lt;p&gt;　さて、DIPのフックもEndSceneと基本的に変わらない。vTableからのオフセットを調べ、そのアドレスを逆アセンブルしてMid-Function Hookのための計画を立てる。私の環境ではvTable[82]にDrawIndexedPrimitiveメソッドがあった。（D3D9ならどの環境でも同じ場所にあるだろう。）また、DrawIndexedPrimitiveメソッドは次のようになっていた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;DIP+00h : 8BFF    : mov edi, edi
DIP+02h : 55      : push ebp
...
DIP+2Dh : 8965 F0 : mov [ebp-0x10], esp
DIP+30h : 8B75 08 : mov esi, [ebp+0x8]
DIP+33h : 85F6    : test esi, esi
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　個人的な流儀で「mov reg, [ebp+0x8]」のところ（pDeviceを取得したところ）にjmpを配置するようにしているが、実行される部分であればどこでもよい。私の環境ではDIPの先頭から0x30の地点にこれがあるので、ここをjmpで上書きする。DIP+30hは3バイトで、DIP+33hは2バイトなので、これで丁度jmp命令の5バイトが上書きされる。（つまり、nopは必要ない。）前に作成した関数を使用すると、フックは次のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;DrawIndexedPrimitive_hook = vTable[82] + 0x30;
DrawIndexedPrimitive_ret = DrawIndexedPrimitive_hook + 5;
MakeMFH((PBYTE)DrawIndexedPrimitive_hook,
        (DWORD)hook_DrawIndexedPrimitive,
        3 + 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　次にhook_DrawIndexedPrimitive関数を作るのだが、ここで注意したいのが、DIPは引数を取るということである。具体的にはDIPは次のように定義される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;HRESULT DrawIndexedPrimitive(
    D3DPRIMITIVETYPE Type,
    INT BaseVertexIndex,
    UINT MinIndex,
    UINT NumVertices,
    UINT StartIndex,
    UINT PrimitiveCount
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前に説明したようにebp+0x8がpDeviceで、第一引数はebp+0xCから始まる。これを考慮したhook_DrawIndexedPrimitive関数は次のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;__declspec(naked) void hook_DrawIndexedPrimitive()
{
    static LPDIRECT3DDEVICE9 pDevice;
    static D3DPRIMITIVETYPE pType;
    static INT BaseVertexIndex;
    static UINT MinIndex;
    static UINT NumVertices;
    static UINT StartIndex;
    static UINT PrimitiveCount;
    // pDeviceを取得する
    __asm {
        mov esi, [ebp + 0x08]
        mov pDevice, esi;
    }
    // 各種引数を取得する
    __asm {
        mov esi, [ebp + 0x0C]
        mov pType, esi
        mov esi, [ebp + 0x10]
        mov BaseVertexIndex, esi
        mov esi, [ebp + 0x14]
        mov MinIndex, esi
        mov esi, [ebp + 0x18]
        mov NumVertices, esi
        mov esi, [ebp + 0x1C]
        mov StartIndex, esi
        mov esi, [ebp + 0x20]
        mov PrimitiveCount, esi
    }
    // 用意した処理を呼び出す
    my_DrawIndexedPrimitive(pDevice,
                          pType,
                          BaseVertexIndex,
                          MinIndex,
                          NumVertices,
                          StartIndex,
                          PrimitiveCount);
    // 上書きした命令を実行してから元の場所に戻る
    __asm {
        mov esi, [ebp + 0x8]
        test esi, esi
        jmp DrawIndexedPrimitive_ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ところで、このようにアセンブリを書けない方は、Microsoft Researchの提供するDetoursというライブラリを使用することをおすすめする。Detoursでは関数1つでフックが完了する。ただ、今回は具体的な構造を処理を理解するために手動でフックした。&lt;/p&gt;

&lt;h2 id=&#34;オブジェクトを特定する&#34;&gt;オブジェクトを特定する&lt;/h2&gt;

&lt;p&gt;　これでDIPをフックできるので、あとはpDeviceを使用して特定のオブジェクトのテクスチャを赤色に変更する処理を書けばよい。ここで問題なのが、DrawIndexedPrimitiveメソッドにはオブジェクトを特定できるようなIDなどは引数にないということである。そこで一般的に使用されるのが、引数のNumVertices、PrimitiveCountやpDeviceの持つGetStreamSourceメソッドである。
NumVerticesは使用される頂点数である。頂点数はたいていオブジェクトによって異なるため、これを利用してオブジェクトを区別できる。また、GetStreamSourceにより取得できるStrideという変数もオブジェクトの区別によく使われる。そうなると次に必要なのは、あるオブジェクトのNumVerticesやStrideを取得することである。これには、一度my_DrawIndexedPrimitiveでOutputDebugStringなどを使ってログを取る方法などがある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;TCHAR str[64] = TEXT(&amp;quot;&amp;quot;);
wsprintf(str,
         TEXT(&amp;quot;Stride=%d &amp;amp;&amp;amp; NumVertices=%d&amp;quot;),
         Stride,
         NumVertices);
OutputDebugString(str);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　DebugViewなどでこのログを見るだけでも、オブジェクト特定に繋がる。ちなみにFPSの人間など、部位が細かく分けられているオブジェクトでは複数のNumVerticesを指定しないと部分的にテクスチャを変更してしまう。今回のShadowMap.exeでぐるぐる回っている飛行機をログから特定したところ、Strideは32、NumVerticesは200代の値であった。（今回は飛行機の大部分を赤色に変更するが、細かい部分は元のテクスチャのままである。）&lt;/p&gt;

&lt;h2 id=&#34;wallhackの仕上げ&#34;&gt;Wallhackの仕上げ&lt;/h2&gt;

&lt;p&gt;　前節の結果より、my_DrawIndexedPrimitive関数にWallhackのメイン処理を書く。まず、NumVerticesからオブジェクトを特定したら、取得したpDeviceのSetTextureメソッドによりテクスチャを設定する。以下にテクスチャを作成する関数と、my_DrawIndexedPrimitive関数を示す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
    テクスチャを生成する
*/
bool GenerateCham(IDirect3DDevice9 * pDevice,
                  LPDIRECT3DTEXTURE9 *texture,
                  DWORD colorARGB)
{
    if (FAILED(pDevice-&amp;gt;CreateTexture(8, 8, 1, 0,
                                      D3DFMT_A4R4G4B4,
                                      D3DPOOL_MANAGED,
                                      texture,
                                      NULL)))
        return false;
    WORD color16 = ((WORD)((colorARGB &amp;gt;&amp;gt; 28) &amp;amp; 0xF) &amp;lt;&amp;lt; 12)
        | (WORD)(((colorARGB &amp;gt;&amp;gt; 20) &amp;amp; 0xF) &amp;lt;&amp;lt; 8)
        | (WORD)(((colorARGB &amp;gt;&amp;gt; 12) &amp;amp; 0xF) &amp;lt;&amp;lt; 4)
        | (WORD)(((colorARGB &amp;gt;&amp;gt; 4) &amp;amp; 0xF) &amp;lt;&amp;lt; 0);
    D3DLOCKED_RECT d3dlr;
    (*texture)-&amp;gt;LockRect(0, &amp;amp;d3dlr, 0, 0);
    WORD *pDst16 = (WORD*)d3dlr.pBits;
    for (int xy = 0; xy &amp;lt; 8 * 8; xy++) *pDst16++ = color16;
    (*texture)-&amp;gt;UnlockRect(0);
    return true;
}

VOID WINAPI my_DrawIndexedPrimitive(LPDIRECT3DDEVICE9 pDevice,
                                    D3DPRIMITIVETYPE Type,
                                    INT BaseVertexIndex,
                                    UINT MinIndex,
                                    UINT NumVertices,
                                    UINT StartIndex,
                                    UINT PrimitiveCount)
{
    LPDIRECT3DVERTEXBUFFER9 Stream_Data;
    UINT Stride, offset;
    LPDIRECT3DTEXTURE9 chameleon;

    if (pDevice-&amp;gt;GetStreamSource(0,
                                 &amp;amp;Stream_Data,
                                 &amp;amp;offset,
                                 &amp;amp;Stride) == D3D_OK) {
        Stream_Data-&amp;gt;Release();
    }

    if ((Stride == 32 &amp;amp;&amp;amp; (
        NumVertices == 245 ||
        NumVertices == 232 ||
        NumVertices == 256))) {
        // テクスチャを設定する
        GenerateCham(pDevice,
                     &amp;amp;chameleon,
                     D3DCOLOR_ARGB(255, 254, 0, 0));
        pDevice-&amp;gt;SetTexture(0, chameleon);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これら全てをまとめたプログラムは次のURLからダウンロードできる。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/qr_code2.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ptr-yudai/jokenoffline/blob/master/wallhack02.cpp&#34;&gt;https://github.com/ptr-yudai/jokenoffline/blob/master/wallhack02.cpp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　早速実行してみよう。対象とするプログラムはDirect3Dのサンプルにある「ShadowMap.exe」である。DLLインジェクションにより作成したDLLをロードさせると、図に示したようにフックが成功していることが確認できる。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/wallhack_test_2.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;DIPのフックによるテクスチャの変更&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h1 id=&#34;不正対策&#34;&gt;不正対策&lt;/h1&gt;

&lt;p&gt;特にオンラインゲームなど、一人の不正が不特定多数のプレイヤーに影響を与えてしまう場合、ゲームガードと呼ばれる不正対策機構が使用される。ゲームガードはインジェクションの検知以外にも、あらゆるチートに対する防御機構を備えている。しかし、実際にはゲームガードが実行されるマシンはチート利用者の手中にあるため、必ずチート利用者が有利になってしまう。そのため、現状ではいかにゲームガードの解析や回避を面倒にするかに重点をおいて研究されている。（パッカーや難読化など。）&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/cheat_detected.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;ゲームガードに不正行為が検知された例&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;ゲームガードに検知されないコードはUD(Undetected)などと呼ばれてインターネットに出回っている。もちろんゲームガードの解析や回避は利用規約によって禁止されているので、決して試さないこと。&lt;/p&gt;

&lt;h1 id=&#34;参考文献&#34;&gt;参考文献&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Mid-Function Hook, that big deal? (2016/01/05)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.unknowncheats.me/forum/c-and-c-/67884-mid-function-hook-deal.html&#34;&gt;https://www.unknowncheats.me/forum/c-and-c-/67884-mid-function-hook-deal.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Special Force D3D9 (Wallhack, XQZ, Crosshair) (2016/01/04)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.unknowncheats.me/forum/other-fps-games/71550-special-force-d3d9-wallhack-xqz-crosshair.html&#34;&gt;http://www.unknowncheats.me/forum/other-fps-games/71550-special-force-d3d9-wallhack-xqz-crosshair.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Injectable Mid Function Hook (2016/01/06)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.unknowncheats.me/forum/d3d-tutorials-and-source/68900-injectable-mid-function-hook.html&#34;&gt;http://www.unknowncheats.me/forum/d3d-tutorials-and-source/68900-injectable-mid-function-hook.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;IDirect3DDevice9 インターフェイス (2016/01/05)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/cc324252.aspx&#34;&gt;https://msdn.microsoft.com/ja-jp/library/cc324252.aspx&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;うさみみハリケーン: &lt;a href=&#34;http://hp.vector.co.jp/authors/VA028184/#TOOL&#34;&gt;http://hp.vector.co.jp/authors/VA028184/#TOOL&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>PCの冷却のおはなし</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/neces_of_cool/</link>
      <pubDate>Fri, 07 Apr 2017 19:49:59 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/neces_of_cool/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;冷却の必要性&lt;/p&gt;

&lt;p&gt;「PCの発熱なんてたかがしれてるでしょ。」そう思ってはいませんか。私はそう思っていました。しかし、実際に温度を計測してみると結構熱を持っていることがわかります。特にCPUはファンを使った状態でも40°を余裕で超えることがあります。特に特にGPUは70℃に達することもあります。熱を持つとどのような悪影響があるのか。まず熱暴走が考えられます。熱暴走は熱によって電子回路に悪影響が及び、その名の通り処理が暴走することです。また、物理的に故障する場合もあります。ライトユーザーなら心配する必要はまずないですが、OCをガンガンして3Dゲームをガリガリ動かすヘビーユーザーは冷却には少しは気を配ったほうがよいでしょう。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;個々のパーツの冷却&lt;/p&gt;

&lt;p&gt;まずは、冷却が必要なパーツを一つ一つ細かく見ていきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　冷却といったらまずはこのパーツを思い浮かべるでしょう。どのパソコンにも必ずついているのがCPUクーラーです。このCPUクーラーは、主に2つの部分に分けることができます。ヒートシンク部分とファン部分です。CPU表面に接しているプレートに熱が移動し、さらにヒートパイプに熱が移動し、さらにヒートシンクに熱が移動し、そこでファンによって冷却される仕組みです。程度の差はあれどもだいたいがこんなかんじです。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu1.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;CPUクーラーの概略図(サイドフロー)&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　CPUクーラーにはご存じの通りCPU製造メーカーが直々に販売している純正クーラー（リテールクーラー）があります。ライトユーザーならこれで十分ですが、ヘビーユーザーとなると別売のより性能の優れているCPUクーラーを買う必要があります。また、別売のCPUクーラーの大半はファンを汎用のケースファンで取り換え可能なものが大半です。より冷却、静穏にすぐれるファンに取り換えることも可能なのです。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu2.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;メーカー純正のリテールクーラー。見ての通りトップフローである。&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　CPUクーラーは形状によって大きく二種類に分けることができます。サイドフローとトップフローです。名前から察しがつくと思いますが、サイドフローはファンがマザーボードに対して直角に、トップフローは平行に取り付けられています。それぞれに利点と欠点があります。&lt;/p&gt;

&lt;p&gt;　サイドフローはゲーミングPCに向いているといえます。背が高い分ヒートシンクの表面積が増え、大型のファンを搭載することで冷却性能を高めることができます。そして個人的に一番の利点だと思うのは、ケース内で空気の流れを作り出すことができることです。サイドフローは前面から背面に空気が流れます。この流れをケース内でうまく配置してやると、ケース全体で前面から背面への空気の流れを作ることができます。ケース内の空気の流れについては後ほど触れていきます。もちろん欠点もあります。まず背が高い分ケース内に収まらないことがあるということです。特にミニタワーのケースでは厳しくなってくるでしょう。ミドルタワーでぎりぎりといったところでしょうか。また、空気がマザーボードに対して平行に流れるのでマザーボード上にある他のパーツ（RAMなど）を冷却することが困難になります。&lt;/p&gt;

&lt;p&gt;　トップフローはリテールクーラーに代表されるものです。ファンがマザーボードに対して平行に取り付けられているので背が低い分省スペースになりやすく、ミニタワーといったITXのPCに向いています。また空気の流れがマザーボードに垂直に当たるのでマザーボード上の他のパーツの冷却に期待できます。欠点としては、まず空気の流れがマザーボードに垂直なため、ケース内の前面から背面への空気の流れを阻害してしまいます。またケース側面に空気取り込み穴がないと冷却の効果が薄まります。個人的に一番致命的なのは、非常に取り付けが面倒だということです。ファンの直径はCPUファン取り付けの穴の対角線の長さより当然大きくなります。そのため取り付けるときにヒートシンクの下に指を入れ込む形になり非常に取り付けにくくなります。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu3.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;トップフローの上面図。CPUクーラーの固定穴よりラジエーターのほうが大きい。&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;GPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　GPUの冷却性能は販売されているグラフィックボードによって依存します。メーカー純正の場合はファンが一つのことが多いですが、他のメーカーが販売している場合はファンが二つついていることが多く、OCモデルとなると三つついてくる場合もあります。GPUを選択したら、クロックのほかに、ファンの冷却性能や静音性を調べてみてはどうでしょうか。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu4.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Nvidia純正のグラボ。ファンが一つである。&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu5.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;ASUS製のグラボ。GPUは図4と同じだがファンが三つついている。&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;ストレージ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　SSDやHDDも熱を持ちますが、専用の冷却パーツを取り付ける必要はないでしょう。ケース内の空気の流れで十分です。しかし、後述するM.2 SSDは別です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;M.2 SSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　M.2 SSDは転送規格にPCI Expressを用いることでSATAでは考えられないような転送速度を実現した新世代のストレージですが、冷却には要注意、いや、要要注意です。処理速度が高まった分発熱がバカにならないほど高く、個別の冷却パーツは必須です。&lt;/p&gt;

&lt;p&gt;筆者も用いているおすすめの方法は、ヒートシンクをのっけるだけ。これだけです。非常に単純ですがこれだけで冷却性能が格段に向上します。できるだけ大きなヒートシンクを使いましょう。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu6.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;M.2 SSDとヒートシンク。大きなヒートシンクを使ったほうが冷却性能は当然高まる。&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;　さらに冷却性能を追求したい場合は、小型ファンを追加するとよいでしょう。このファンでヒートシンクを冷やしてあげることでさらに冷却性能が向上します。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu7.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;ヒートシンクの上に小型ファンを挟んだ例。冷却性能により磨きがかかった。&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;しかし注意点がひとつ。クリップ式のファンを用いてヒートシンクに止める場合、自重で落下する場合があります。また、基板上にシールが貼ってあり、その上からヒートシンクを乗せた場合は、ヒートシンクがシールごとはがれる場合があります。&lt;/p&gt;

&lt;p&gt;　最近SilverStoneからM.2 SSD専用のサーマルパッドが発売されました。性能はまだまだ未知数なので、だれか筆者の人柱となって性能を確認してください。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ケース全体での冷却&lt;/p&gt;

&lt;p&gt;　ケース全体での冷却を考える場合、「ケース内の空気の流れ」と「正圧と負圧」です。二つめの正圧と負圧はぶっちゃけ気にしなくていいのでパパっと終わらせます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ケース内の空気の流れ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　ケース全体での冷却で重要になってくるのは、「ケース内で風の流れを作る」ことです。しっかりと風が通り抜けるようにしないと、「全部吸い込むようにケースファンを取り付けてしまった」なんてことになるととんでもないことになります。
これからいくつかの図を使って風の流れを説明しますが、赤は吸い出し用ファンの風の流れ、青は吐き出し用のファンの風の流れを表します。矢印の太さは通る風の流れの量を表しています。なお、図には5インチ米や3.5インチベイが描かれていませんが決して手抜きではありません。えぇ、手抜きなんかじゃありません。&lt;/p&gt;

&lt;p&gt;まず、一つ目は一般的なケースです。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu8.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;一般的なケースは購入時に後ろにファン一つが搭載されている状態です。まあグラボも高性能CPUも使うつもりがないならこれで十分なわけです。しかし、ゲーミングではGPUもCPUもバリバリ使っていくのでこれでは少し苦しいわけです。そこでファンを一つ追加してみます。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu9.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;前面に直径の大きなファンを追加してみました。これでずいぶん冷却性能が上がりました。前面のケースファンはうまくいけばHDDも冷却することができます。そしてここにあるものを追加してみます。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu10.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;かなり大きいですね。グラボです。（今回はファンが二つ付いているものを想定しています。）このグラボが追加されるだけで一気に窮屈さが増します。スペックの低いグラボだとこのままでも大丈夫ですが、スペックの高いグラボだと少々風が不足する場合もあります。そのような場合は底面にケースファンを追加してみましょう。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu11.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;底面のケースファンによりグラボにも十分な風がいきわたるようになりました。これで十分なのですが、さらに冷却を求める場合は上面に排気用のケースファンを追加するのも良いでしょう。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/zu12.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;正圧と負圧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　名前から察しがつくと思いますが、圧力のお話です。といってもそこまで難しくはありません。超簡単です。なのでパパっとやって、終わりっにしましょう。&lt;/p&gt;

&lt;p&gt;　正圧とは、ケース内の圧力が部屋の圧力より高い状態です。つまりパンパンなわけですね。空気というのは圧力の高いところから低いところに移動するのでケース内の空気はケース内から部屋に移動します。逆に負圧はケース内の圧力が部屋の圧力より低い状態です。空気は部屋からケース内に移動します。この正圧と負圧でどうちがうの？ということですが、ぶっちゃけあまりかわりません。正圧の場合空気がケースの隙間から漏れ出すからほこりが入らないといわれていますが、正直微妙なところです。また時間があったらいろいろ調べてみたいと思っていますが、たいした戦果は得られないでしょう。かなり微妙なところですから。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;おわりに&lt;/p&gt;

&lt;p&gt;　さて、このような冷却に関することは実際にCPUやGPUの温度を測定しながら試行錯誤してもいいのですが残念ながら筆者にそのようなことをする時間はありません（大嘘）。時間があったらぜひやってみたいです。&lt;/p&gt;

&lt;p&gt;　現在筆者はパーツ選びの指南書なんかもつくっています。そちらでは各パーツのおすすめメーカーなどを挙げています。きになる方はぜひJokenに来てくださいね！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>無限に続く迷宮を作る(誇張)</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/make_eternal_maze/</link>
      <pubDate>Fri, 07 Apr 2017 19:17:57 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/make_eternal_maze/</guid>
      <description>

&lt;h1 id=&#34;あいさつ&#34;&gt;あいさつ&lt;/h1&gt;

&lt;p&gt;　情報工学科のふるつきといいます。去年は、サイバーセキュリティまわりの競技やスーパーコンピューティングコンテストで成績を残しました。一方で、高専プロコンでは大敗を喫して面目丸つぶれも経験しました（これは二回目のことで、一昨年は去年よりももっと酷い負け方をしてました）。&lt;/p&gt;

&lt;p&gt;JOKENではそんな感じでサイバーセキュリティまわりのことをしたり、あとは、LT（LightningTalkのこと。5-10分程度の短い発表）を開催してみたりと、「わいわい盛り上がってうぇいうぇいしたい」的な欲求の実現に向けて日々精進したりしています。&lt;/p&gt;

&lt;p&gt;その一方で、私は「現代視覚文化研究会」にも所属しており、こちらではなーんにもしていないのですが、毎年、高専祭のために一本ゲームを作る活動だけはなんとか続けています。今年は本当にぎりぎりのスケジュールで、当日もまだ新しいバグを見つけたり、未実装の機能をだましだましで動かしたりしていました。ふらふらコスモノートというゲームで、&lt;a href=&#34;http://nnct-mvccc.sakura.ne.jp/products/584291b663643/index.html&#34;&gt;http://nnct-mvccc.sakura.ne.jp/products/584291b663643/index.html&lt;/a&gt; で公開していますので一度遊んでみてください。&lt;/p&gt;

&lt;p&gt;今回はこのふらふらコスモノートを作ったときのアルゴリズムの話を書きます。新入生のうちのいくらかがちょっと期待しているゲームの話で、それなりに頭をつかうので、悪くない題材だと思います。げんしけんのマーケティングが混じってることを除けば。&lt;/p&gt;

&lt;h1 id=&#34;迷宮を作る&#34;&gt;迷宮を作る&lt;/h1&gt;

&lt;h2 id=&#34;作りたいもの&#34;&gt;作りたいもの&lt;/h2&gt;

&lt;p&gt;　ふらふらコスモノートは、宇宙飛行士が、宇宙空間をふらふらと彷徨うゲームなのですが、宇宙が無限に広がっているわけではなくスペースデブリの隙間を縫って先に進む必要があります（そういう設定です）。この、スペースデブリの迷路を、無限の長さにしたい、というのが当初の要望でした。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/field.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;迷宮(迷宮っぽくないとか言わない)&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;上の図みたいな迷宮が無限に続くみたいなのをイメージしています。&lt;/p&gt;

&lt;h2 id=&#34;無限の迷宮がつくれるか&#34;&gt;無限の迷宮がつくれるか&lt;/h2&gt;

&lt;p&gt;　無限の迷宮ってどうやって作るんでしょうね？　作ったとして、有限のメモリのどこに保存しておくんでしょうね？&lt;/p&gt;

&lt;p&gt;こういう疑問が出てくるのは当たり前ですね。というか、前提条件ですね。「無限の迷路を作りたいなぁ」と思ったときに、実際に無限の空間を生成しようとするのは愚かなことです。それは無限の満たすべき要件を間違えています。&lt;/p&gt;

&lt;p&gt;無限の迷宮というのは「途切れることのない」迷宮です。まだ見えない場所に何があるかなんて、気にする必要はありません。「いままでに訪れた場所」と「これから訪れる場所」ができていれば、それでよいというわけです。「これから訪れる場所」も今いる場所から1px先とか2px先とかでも良いわけで、最後までたどり着くかわからないような場所を生成する必要はありません。&lt;/p&gt;

&lt;p&gt;さらにふらふらコスモノートは強制スクロール式のゲームです。「今まで訪れた場所」にもう一度訪れることは有りえません。というわけで、必要な迷宮は「画面の中」と「画面の少し先」の部分だけで、ずうっと先なんて生成する必要はないし、いままで訪れた場所をずっと保存しておく必要もなくなりました。だいぶ問題が簡単になりましたね。&lt;/p&gt;

&lt;p&gt;これで「無限っぽく感じる迷宮」を作れそうです。もっというと「無限のインタフェースを満たした迷宮」ですかね。アヒルのように鳴き、アヒルのように歩くものはアヒルだという話です。&lt;/p&gt;

&lt;h2 id=&#34;実装する&#34;&gt;実装する&lt;/h2&gt;

&lt;p&gt;　実装します。もっと細かいことを決めてから実装をはじめるのも良いと思いますが、私は書きながら「あれ？　ここも決めないとな」とか言ってその場で適当に決めてしまうタイプの人間です（こういうタイプの人間は大したものは作れないことになっていて、大したものを作りたい場合はしっかり設計を固めてから実装しましょう。実装が考えてやるものではなくて「やるだけ」と言えれば上々な気がします）。&lt;/p&gt;

&lt;p&gt;まずはどのくらいの単位で作っていくかを決めましょう。つまり、画面いっこをドーンと生成するのか、それとも、1マスずつ生成していくのかという話です。&lt;/p&gt;

&lt;p&gt;今回は、一行ずつ作ることにしました。n行で一画面になります。こういう方針にしたのは、画面をスクロールするときには一行単位で更新するからです。&lt;/p&gt;

&lt;p&gt;　では、この一行が満たすべき要件は何でしょうか。今回の場合は「1マス以上の幅の穴が一箇所だけあいている」ことになりそうです。さらに「前の行の穴から連続している」という条件も必要ですね。これらを満たさない一行が混じった場合の迷宮のイメージ図を後に載せますが、辿り着けない穴が開いていたり、最悪行き止まりになってしまうという場合が生まれます。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/badfield.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;だめな迷宮&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;ほんとに実装する&#34;&gt;ほんとに実装する&lt;/h2&gt;

&lt;p&gt;前節では実装すると言ってしなかったので、本節では本当に実装していきます。ここではPythonを使います。&lt;/p&gt;

&lt;h3 id=&#34;最初の実装&#34;&gt;最初の実装&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def makeLine(width):
    return [0 for i in range(width)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;穴は1、非穴は0で表現することにして、一行を配列に収めます。$[&amp;hellip;]$ の部分はちょっとPython独自の記法なのでわからない人にはわからないと思いますが、大きさ $width$ の配列を生成します。今回は0で埋まっています。&lt;/p&gt;

&lt;p&gt;さて、ここに穴をあけていきます。穴は、とりあえず適当な場所に、適当な大きさの穴をあけちゃいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
def makeLine(width):
    line = [0 for i in range(width)]
    p = random.randrange(width)
    for i in range(random.randrange(width)):
        line[p+i] = 1
    return line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ランダムな場所から、ランダムな大きさの穴をあけます。とはいえ、今は、ほんとうにランダムにしているので、配列の範囲外にアクセスしてしまいかねません。もうちょっと改善しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
def makeLine(width):
    line = [0 for i in range(width)]
    p = random.randrange(width)
    for i in range(random.randrange(width-p)):
        line[p+i] = 1
    return line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このあたりはPythonのrandomモジュールについての知識が必要になってややこしいですが、穴を開ける時の幅を、範囲外アクセスがない程度に収めます。&lt;/p&gt;

&lt;p&gt;いまの状態で、例えば10行を生成すると、こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
[0, 1, 1, 1, 1, 1, 1, 1, 0, 0]
[0, 0, 1, 1, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]
[0, 0, 1, 1, 1, 1, 1, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 1, 1, 1, 0, 0, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;穴のあいていないところや、前の行から連続して辿れないところがあってちょっと問題ですね。これらを改善していきましょう。&lt;/p&gt;

&lt;h3 id=&#34;最小の幅をきめる&#34;&gt;最小の幅をきめる&lt;/h3&gt;

&lt;p&gt;とりあえず、最小の穴のサイズを決めましょう。現状だと、穴の大きさが0ということが有りうるのですが、これはちょっといただけませんからね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
def makeLine(width, holeminwidth):
    line = [0 for i in range(width)]
    p = random.randrange(width-holeminwidth)
    for i in range(random.randrange(holeminwidth, width-p)):
        line[p+i] = 1
    return line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;holeminwidthという引数を追加して、少なくともこの大きさの穴が空くようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000111110
0000111100
0111111110
0000111100
1111111100
0111100000
0000011110
0011111110
1111110000
0001111000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;適当に生成しました。実にいい感じですが、真ん中のあたりでぶっつり途切れてしまっていますね。というわけで、次はこの辺を修正していきます。&lt;/p&gt;

&lt;h3 id=&#34;前の行と合わせる&#34;&gt;前の行と合わせる&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
def makeLine(width, holeminwidth, prevbegin, prevend):
    line = [0 for i in range(width)]
    p = random.randrange(max(0, prevbegin-holeminwidth), min(width-holeminwidth, prevend+holeminwidth))
    for i in range(random.randrange(holeminwidth, width-p)):
        line[p+i] = 1
    return line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しく引数にprevbeginとかprevendを追加しました。これは、前の行の穴の開始位置と終了位置を表していて、少なくともこの間に穴を一つ開けておけば、道はつながります。さらに、次の行のために今回の行の開始位置と終了位置を返すようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
def makeLine(width, holeminwidth, prevbegin, prevend):
    line = [0 for i in range(width)]
    p = random.randrange(max(0, prevbegin-holeminwidth), min(width-holeminwidth, prevend+holeminwidth))
    w = random.randrange(holeminwidth, width-p)
    for i in range(w):
        line[p+i] = 1
    return line, p, p+w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;適当に50行くらい生成してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0001111100
0000011110
0000111110
0001111110
0011111110
0001111000
0011111110
0011111100
1111110000
0001111100
0011111000
0111110000
0000111100
0000011110
0001111100
0001111000
0001111100
0000011110
0001111100
1111111110
0001111110
1111111100
0011110000
0000111100
0011111000
0111111000
0000011110
0111111100
0000111110
0001111110
0000011110
0000011110
0011110000
0000111100
0000011110
0001111110
0000111110
0111110000
0000011110
0011111110
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/maze.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;生成された迷宮&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;いい感じに見えますね。こんな感じで、あとは難易度に合わせて幅を調整したりすると、迷宮がつくれそうです。&lt;/p&gt;

&lt;h1 id=&#34;おしまいに&#34;&gt;おしまいに&lt;/h1&gt;

&lt;p&gt;ソースコードをこんなにたくさん、重複して乗っけたのに、そんなにページを稼げませんでした。短くて、それなりに親切で、基本を抑えてる人には十分わかる話が書けたとは思っていますが。&lt;/p&gt;

&lt;p&gt;このお話がわかるような人に向けて、少しだけ。こんなサボりじゃなくてちゃんとしたアルゴリズムを考えられる頭を作るほうが良いですよ、ということと、じつは上のプログラムは境界を適当に書きすぎててまだ不具合が残ってるよとかいうことをお伝えしておきます。
 おしまい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>はじめてのアルゴリズム</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/first_step_arugo/</link>
      <pubDate>Fri, 07 Apr 2017 16:42:28 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/first_step_arugo/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;こんにちは．情報工学科3年（新4年）のDaisukeといいます．2年生の冬に日本情報オリンピック本選に出場したことをきっかけにアルゴリズムに興味を持ち3年生の春にJokenに入りました．3年生の夏には古月君とクラスメイトの3人でスーパーコンピューティングコンテストというアルゴリズムを競う大会に出場し，3位に入賞することができました．このようなアルゴリズムを考えてプログラミングするというジャンルのプログラミングを競技プログラミング（以下，競プロ）と呼びます．競プロはプログラミングの知識がほとんど入門レベルでも始めることができるので，プログラミング初心者の方が何か挑戦してみたいと考えるなら，是非競プロについて勉強してみるのはいかがでしょうか．この記事では競プロの説明と，アルゴリズムの例として二分探索法というアルゴリズムについて解説します．&lt;/p&gt;

&lt;h2 id=&#34;about-競プロ&#34;&gt;about 競プロ&lt;/h2&gt;

&lt;h3 id=&#34;競プロの宣伝&#34;&gt;競プロの宣伝&lt;/h3&gt;

&lt;p&gt;本題の前に実際に競プロってどういう大会があるのかについて説明します．競プロはオンラインの大会や，どこかの会場で行う大会もあります．オンラインの大会でもAtCoder(&lt;a href=&#34;https://atcoder.jp/&#34;&gt;https://atcoder.jp/&lt;/a&gt; )というホームページの大会は月に何度かというペースで行っており，だれでも参加することができるのでおすすめです．初心者向けの大会があり，時間も100分で4問なので参加しやすいです．また会場で行う大会は有名なのはやはり日本情報オリンピックです．予選はオンラインで行われますが，本選は関東地方の会場で行われます．本選は4時間で5問解きます．またスーパーコンピューティングコンテストも阪大で行われました．スーパーコンピューティングコンテストは問題が与えられてから2日半くらいの時間で1問解きます．このような会場で行う大会の最大のメリットは，同じくらいの年齢の，同じような興味を持つ人と会うことができることです．しかも名門校が多くてその中に交じれる機会はそうないと思います．僕はとても楽しく，貴重な経験だったと思います．&lt;/p&gt;

&lt;p&gt;ちなみに言語はC・C++が良いです．理由は，情報オリンピック本選ではC言語が強制されるのと，それによって競プロの本もまたC言語で書かれていることが多いからです．&lt;/p&gt;

&lt;h3 id=&#34;競プロのアルゴリズム&#34;&gt;競プロのアルゴリズム&lt;/h3&gt;

&lt;p&gt;この記事を読んでいる人はそのアルゴリズムというもののイメージがついていると思います．僕は，日本語では「方法」に近いイメージを持っていました．Googleで「アルゴリズム」と検索してみると&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;アルゴリズム（英: algorithm [ˈælgəˌrɪðəm]）とは、数学、コンピューティング、言語学、あるいは関連する分野において、問題を解くための手順を定式化した形で表現したものを言う。「 算法」と訳されることもある。&lt;/p&gt;

&lt;p&gt;アルゴリズム - Wikipedia&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/アルゴリズム&#34;&gt;https://ja.wikipedia.org/wiki/アルゴリズム&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書いてあります．ここで重要なのは，定式化した形という部分です．なぜなら曖昧な方法を考えていてはプログラムを書くことができないからです．何を計算するのか，何を繰り返すのかを具体的に考える必要があります．&lt;/p&gt;

&lt;p&gt;競プロの世界では一般的に速く計算をすることができるアルゴリズムを良いアルゴリズムとしています．アルゴリズムの速さを時間計算量と呼びます．時間計算量はプログラムを実行したときの繰り返しの数のことです．オーダー記法という方法で示すことができるので興味のある方は調べてみてください．とりあえず，時間計算量が小さい（＝繰り返しが少ない）アルゴリズムほど良いと言えます．同じ問題を解くのに1万回の繰り返しで済むアルゴリズムと1億回の繰り返しが必要なアルゴリズムでは前者のアルゴリズムのほうが良いということです．目安ですが繰り返しの回数が億になると実行するのに秒単位の時間がかかるのでアルゴリズムが間違っていると考えることが多いです．それより小さければ大体の場合実行すると一瞬で結果が返ってきます．競プロの大会ではプログラムの実行時間が2秒以内とか1秒以内というように決められているので，悪いアルゴリズムだとたとえ正しい答えを出したとしても点数がもらえません．ちなみに僕はアルゴリズムを良いか悪いかはあまり考えないうちにプログラムを書きはじめ，大体後から修正して複雑なプログラム（俗にスパゲッティーコード）を書くのが得意です．反省．（でも長々として複雑なプログラムでも時間内に実行終了すればOK牧場）&lt;/p&gt;

&lt;h2 id=&#34;let-s-二分探索法&#34;&gt;Let&amp;rsquo;s 二分探索法&lt;/h2&gt;

&lt;h3 id=&#34;二分探索法の前に&#34;&gt;二分探索法の前に&lt;/h3&gt;

&lt;p&gt;良いアルゴリズムの典型的な例として二分探索法というものがあります．これは昇順や降順に値が格納されている配列から特定の値を探し見つけ出すアルゴリズムです．もちろん配列の探索に限らずいろいろな問題を解くときに応用することができます．良いと言っているくらいなので時間計算量が小さいです．しかし，二分探索法をいきなり説明する前に，普通の配列の探索のアルゴリズムについて考えてみてから，二分探索法がいかに良いのかについて考えてみましょう．&lt;/p&gt;

&lt;h3 id=&#34;普通の配列の探索&#34;&gt;普通の配列の探索&lt;/h3&gt;

&lt;p&gt;普通のアルゴリズムは配列を先頭から順にチェックして探してる値じゃなければ次の値をチェック，というものです．Javaのプログラムを示しておきます．（Javaである意味はないです）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;普通のアルゴリズム(Java)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;public class Futsu {
    public static void main(String[] args) {
        int[] ar = {3,7,10,13,19,20,24};    //探索する配列（昇順）
        int key = 10;               //探す値
        for(int i=0;i&amp;lt;ar.length;i++){
            if(ar[i]==key){
                System.out.println(i+&amp;quot;番目に発見&amp;quot;);
                return;
            }
        }
        System.out.println(&amp;quot;ない&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムを実行するとコンソールには「2番目に発見」と出力されます．繰り返しの数はiが0,1,2となるので3回です．もし，keyがほかの値ならどうでしょうか．例えば存在しない30だった場合．この時は7回繰り返して配列の最後までチェックして「ない」と出力されます．また，配列に1000個値が格納されている場合には，最大で1000回繰り返す必要があります．このように，この普通のアルゴリズムは最大で配列の大きさと同じ回数繰り返す必要があります．繰り返しの数の最小なのは先頭の値が探す値だった場合で配列の大きさに関係なく1回で終了します．しかし競プロの世界では，実行時間に何秒以内という制限はあっても，何秒以上かけろという制限はないので最小の時間はあまり気にする必要がありません．制限を満たすには，最大を見るべきです．（例の1000個はまだ小さい値なので一瞬で答えが返ってきます．）&lt;/p&gt;

&lt;p&gt;結論として，普通のアルゴリズムでは配列の大きさと同じだけ繰り返しの数が増えます．&lt;/p&gt;

&lt;h2 id=&#34;二分探索法&#34;&gt;二分探索法&lt;/h2&gt;

&lt;p&gt;前節の普通のアルゴリズムを踏まえたうえで，二分探索法について見てみましょう．&lt;/p&gt;

&lt;p&gt;二分探索法は配列が昇順でも降順でも，ある順序に従って格納されている場合にのみ使えます．（デメリットで，順序に並んでいない場合は使えません）まず，配列の真ん中に格納されている要素を見ます．先ほどのプログラムlisting1では13が真ん中にあります．配列は昇順に並んでいるので，もし探している値10が配列に入っているのであれば，13よりは後にあるはずです．よって1回のチェックで調べる範囲をいきなり7個から3個まで減らすことができました．この次も残る3つのうち真ん中をチェックします．この時真ん中にあるのは7です．よって先ほどと同じように，探している10は7よりも後にあるはずです．そして残る値が1つになったのでチェックするとそれが探していた10でプログラムが終了します．さて，繰り返しは3回行いました．普通のプログラムと変わらないです．しかし，この方法であれば存在しない値30を探した場合でも，13（後），20（後），24(後)となり，3回の繰り返しで終了します．この二分探索法では配列の大きさが7の場合は最大でも3回しか繰り返しません．また，配列の大きさが1000の場合でも，最大で10回の繰り返しで終了します．逆に5回の繰り返しでは32個の要素を持った配列を探索することができます．これは，n回の繰り返しで2のn乗の大きさまでの配列を探索できると考えてください．&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/bs.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;プログラムを示しますが，多少複雑なのでプログラムは理解しなくてもいいので，アルゴリズムを理解してください．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;二分探索法(Java)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BinarySearch {
    public static void main(String[] args) {
        int[] ar = {3,7,10,13,19,20,24};    //探索する配列
        int key = 10;               //探す値
        int upper = ar.length;      //探す範囲の上限
        int lower = 0;              //探す範囲の下限
        int mid;                    //真ん中の値
        while(lower&amp;lt;=upper){
            mid = (lower+upper) / 2;
            if(ar[mid]==key){       //見つけたとき
                System.out.println(mid+&amp;quot;番目に発見&amp;quot;);
                return;
            }else if (ar[mid] &amp;lt; key) {
                lower = mid + 1;    //もっと前
            } else {
                upper = mid - 1;    //もっと後ろ
            }
        }
        System.out.println(&amp;quot;ない&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;最後に，二分探索法の特徴についてまとめておきます．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;真ん中の要素から調べることで配列を半分ずつに分ける．&lt;/li&gt;
&lt;li&gt;大きな配列でも少ない繰り返し回数で探索することができる．&lt;/li&gt;
&lt;li&gt;順番に並んでいる配列じゃないと使うことができない．&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;おわり&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;当たり前ですが，二分探索のほかにもアルゴリズムはたくさんあります．アルゴリズムとデータ構造と検索すればたくさんの本が見つかるので競プロに挑戦するのであれば読んでみてほしいと思います．データ構造というのがついてくるのは，アルゴリズムごとに最適なデータ構造を選択する必要があるので，切っても切り離せないくらい重要な関係だからです．また，本格的に競プロを学びたい場合は，Jokenには俗に蟻本と呼ばれる競プロの神のような人が書いた本があるのでぜひ読んでみてください．&lt;/p&gt;

&lt;p&gt;競プロはスキルアップを必ずサポートしてくれるのでぜひ挑戦してください．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>マインスイーパーを作ろう</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/mine_sweeper/</link>
      <pubDate>Fri, 07 Apr 2017 15:46:08 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/mine_sweeper/</guid>
      <description>

&lt;h3 id=&#34;はじめに&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;　プログラミングを始めて1年程度のものですがよろしくお願いいたします。&lt;/p&gt;

&lt;p&gt;　これは、マインスイーパを題材にして簡単なゲームをどのように作っていけばいいかの例を示すことができたらいいなと思って書きました。
基本的にjavaで説明していきますが開発環境の準備などについては省略させていただきます。ご了承ください。また、非効率なソースなど見苦しい点もあるかもしれませんがお許しください。&lt;/p&gt;

&lt;h3 id=&#34;マインスイーパとは&#34;&gt;マインスイーパとは&lt;/h3&gt;

&lt;p&gt;　まず皆さん、マインスイーパを知っていますか？windows7などに入っていたりしたので遊んだことがある人も多いと思います。
マインスイーパは、たくさんのマスからできた盤面上にいくつかの爆弾が隠されており、爆弾のないマスには周囲にいくつの爆弾が存在するかの値が書かれています。これらのマスは最初は何も書かれていないですが、開けていくことで値がわかるようになり、これらの値をもとにして爆弾のないマスすべてを開くことができたらクリアとなる簡単なゲームです。ここでは、知っているという前提で話させていただきます。&lt;/p&gt;

&lt;h3 id=&#34;コンソール版-java&#34;&gt;コンソール版(java)&lt;/h3&gt;

&lt;p&gt;　まず最初に、コンソールで遊ぶことができるマインスイーパを作っていこうと思います。この時、簡単化された形からまずは考えていきたいと思います。そして、今回は簡単な形として4×4のサイズで爆弾の位置が最初から固定されているものを使います。それを以下に載せます。この時、爆弾を9という値で表し、そのほかの数を周りの爆弾の数を表すようにします。なぜ、爆弾を9という値で表すのかというと、プログラムを書いたことがあればわかると思いますが今回は整数型の二次元配列でフィールドを作るのですが、その時、周りにある爆弾の数は、理論上最大で8個まで可能性があるのでそれより大きい数もしくは、負の数を爆弾として対応させることによって爆弾を表すことができるので、今回は8より1大きい数である9を使いました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;このフィールドをbyte型の二次元配列として宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[][] field = {
                {1,1,1,9},
                {1,9,3,2},
                {2,3,9,1},
                {9,2,1,1}
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　次に、マインスイーパを動作させるのに必要なものを考えていきたいと思います。まず、マインスイーパはマスを開けていくためどのマスが開けられたマスかどうかを記憶しておかなければなりません。(旗はまず考えないでおきます。)そのために、boolean型のフィールドと同じサイズの二次元配列を用意して、開いていたら&lt;strong&gt;true&lt;/strong&gt;、閉じていたら&lt;strong&gt;false&lt;/strong&gt;となるようにします。これで、フィールドの準備はOKです。&lt;/p&gt;

&lt;p&gt;　ほかに必要なものは、入力などを処理する部分です。これらを以下にまとめました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;入力

&lt;ul&gt;
&lt;li&gt;座標で入力される&lt;/li&gt;
&lt;li&gt;指定されたマスの状態を確認&lt;/li&gt;
&lt;li&gt;状態の変更&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;出力

&lt;ul&gt;
&lt;li&gt;配列の表示&lt;/li&gt;
&lt;li&gt;現在の状態&lt;/li&gt;
&lt;li&gt;答え&lt;/li&gt;
&lt;li&gt;クリア、ゲームオーバーの表示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;判定

&lt;ul&gt;
&lt;li&gt;爆弾のないマスすべてが開いたかを調べる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらを実装することで、マインスイーパはつくることができます。&lt;/p&gt;

&lt;p&gt;そのほかにこれらの処理は、クリアもしくはゲームオーバーまで何度も繰り返されるのでループ処理内に記述します。&lt;/p&gt;

&lt;p&gt;では、それぞれの部分を見ていきましょう。&lt;/p&gt;

&lt;h6 id=&#34;入力&#34;&gt;入力&lt;/h6&gt;

&lt;p&gt;　入力では、Scannnerクラスを用いて、入力を座標で入力するようにします。そして、入力された座標のマスが閉じているならば開けて閉じているならば再入力を促します。また、開けるときマスに爆弾があるならばGAMEOVERにします。そして、ループを終了します。&lt;/p&gt;

&lt;p&gt;　この時、座標は m,n としました。これは、x,y としてもかまいません。変えるならば以降変えて見ていってください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Scannerクラスのインスタンスの宣言
Scanner stdIn = new Scanner(System.in);

//座標入力
System.out.print(&amp;quot;m:&amp;quot;);
int m = stdIn.nextInt();
System.out.print(&amp;quot;n:&amp;quot;);
int n = stdIn.nextInt();

//フィールドの確認
if(field[m][n] == 9){
  System.out.println(&amp;quot;ゲームオーバーです&amp;quot;);
}else{
  if(openfield[m][n]){
    System.out.println(&amp;quot;すでに開いています&amp;quot;);
    k--;
    continue;
  }else{
    openfield[m][n] = true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;出力&#34;&gt;出力&lt;/h6&gt;

&lt;p&gt;　次に出力です。出力ではまず、配列の表示をしなければなりません。そのために二重forループを使います。そして、現在の状態の表示ではマスが開いていないなら「&lt;strong&gt;-&lt;/strong&gt;」を表示し、開いているならばそのマスが保持している数字を表示するようにします。また、答えの表示では現在の状態に関係なくすべてのマスを表示しますが、爆弾のマスは「&lt;strong&gt;*&lt;/strong&gt;」を表示するようにします。これらを実装したものを以下に載せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//フィールドの表示
System.out.println(&amp;quot;＜＜＜開いているところ＞＞＞&amp;quot;);
for(int i = 0; i &amp;lt; field.length; i++){
  for(int j = 0; j &amp;lt; field[i].length; j++){
    if(openfield[i][j]){
      System.out.print(field[i][j]);
    }else{
      System.out.print(&amp;quot;-&amp;quot;);
    }
  }
  System.out.println();
}

//終了時処理
System.out.println(&amp;quot;【答え】&amp;quot;);
for(int i = 0; i &amp;lt; field.length; i++){
  for(int j = 0; j &amp;lt; field[i].length; j++){
    if(field[i][j] == 9){
      System.out.print(&amp;quot;*&amp;quot;);
    }else{
      System.out.print(field[i][j]);
    }
  }
  System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;判定&#34;&gt;判定&lt;/h6&gt;

&lt;p&gt;　今回はクリアしたかを判定するためにマスが開けられるたびにカウンタを1ずつ加算していき、その値が最初に設定しておく爆弾のないマスの数に等しくなった時点でクリアとする方式で行きたいと思います。&lt;/p&gt;

&lt;p&gt;　これらがマインスイーパの簡略版の基本です。これらをまとめて、マインスイーパとして仕上げたものを以下に載せておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Scanner stdIn = new Scanner(System.in);
byte[][] field = {
                {1,1,1,9},
                {1,9,3,2},
                {2,3,9,1},
                {9,2,1,1}
        };
boolean[][] openfield = new boolean[4][4];

for(int k = 0;; k++){
  //座標入力
  System.out.print(&amp;quot;m:&amp;quot;);
  int m = stdIn.nextInt();
  System.out.print(&amp;quot;n:&amp;quot;);
  int n = stdIn.nextInt();

  //フィールドの確認
  if(field[m][n] == 9){
    System.out.println(&amp;quot;ゲームオーバーです&amp;quot;);
    break;
  }else{
    if(openfield[m][n]){
      System.out.println(&amp;quot;すでに開いています&amp;quot;);
      k--;
      continue;
    }else{
      openfield[m][n] = true;
    }
  }
  if(k &amp;gt;= 11){
    System.out.println(&amp;quot;クリアです&amp;quot;);
    break;
  }
  //フィールドの表示
  System.out.println(&amp;quot;＜＜＜開いているところ＞＞＞&amp;quot;);
  for(int i = 0; i &amp;lt; field.length; i++){
    for(int j = 0; j &amp;lt; field[i].length; j++){
      if(openfield[i][j]){
        System.out.print(field[i][j]);
      }else{
        System.out.print(&amp;quot;-&amp;quot;);
      }
    }
    System.out.println();
  }
  System.out.println();
}
//終了時処理
System.out.println(&amp;quot;【答え】&amp;quot;);
for(int i = 0; i &amp;lt; field.length; i++){
  for(int j = 0; j &amp;lt; field[i].length; j++){
    if(field[i][j] == 9){
      System.out.print(&amp;quot;*&amp;quot;);
    }else{
      System.out.print(field[i][j]);
    }
  }
  System.out.println();
}
stdIn.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これで、簡単化されたマインスイーパは完成です。&lt;/p&gt;

&lt;p&gt;　しかし簡単化されたものでは、物足りないのでこれをもう少ししっかりしたものにしていきたいと思います。そのために、
まずは、旗を立てることができるようにします。そのために、マスの状態を管理している二次元配列をboolean型のものから
byte型のものにして、2つ以上の状態を保持できるようにします。そして、フィールドの表示でif文の分岐を増やし旗が
立っているとき「&lt;strong&gt;P&lt;/strong&gt;」などの旗とわかる文字を表示するようにします。あと、入力の際に旗を立てるのかマスを開けるのかを
確認するようにして入力をさせるようにして、旗を立てる部分は完成です。&lt;/p&gt;

&lt;p&gt;　次に、爆弾をランダム配置してみたいと思います。そのために、Randomクラスを用いてフィールドのX座標とY座標をランダムに
指定し、そこに爆弾がなければ爆弾を配置するという処理を設置する爆弾の数だけ行います。そして、次に問題になるのが、爆弾のない
マスは周囲にある爆弾の数を持っていなければならないのですが、そのために、フィールドのマスを1ずつ参照していき、周囲に爆弾があれば
そのマスが保持している値を1加算することでマスの値を求めます。その部分のソースを以下に載せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//値の設定
for(int i = 0; i &amp;lt; field.length; i++){
    for(int j = 0; j &amp;lt; field[i].length; j++){
        if(field[i][j] != 9){
            for(int k = -1; k &amp;lt;= 1; k++){
                for(int l = -1; l &amp;lt;= 1; l++){
                    try{
                        if(field[i+k][j+l]==9)field[i][j]++;
                    }catch(ArrayIndexOutOfBoundsException e){
                    }
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにすることで、簡単化されたものからある程度本格的なものになりました。&lt;/p&gt;

&lt;h3 id=&#34;gui版-java-swing&#34;&gt;GUI版(java swing)&lt;/h3&gt;

&lt;p&gt;GUI版の、ソースコードはここに載せるには大きいので、
 &lt;a href=&#34;https://github.com/tadaren/MineSweeper&#34;&gt;https://github.com/tadaren/MineSweeper&lt;/a&gt;
をみてください。そして、解説は面倒なので省きます。&lt;/p&gt;

&lt;h3 id=&#34;javascript版&#34;&gt;javascript版&lt;/h3&gt;

&lt;p&gt;　そして、javascriptでwebで遊べるようにしたものが以下のURLで遊べます。
    &lt;a href=&#34;http://tadaren.webcrow.jp/Minesweeper.html&#34;&gt;http://tadaren.webcrow.jp/Minesweeper.html&lt;/a&gt;
詳しい内容はjavaとほぼ一緒なので解説は省かせていただきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Processingを使ってみよう</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/intro_of_processing/</link>
      <pubDate>Fri, 07 Apr 2017 10:54:02 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/intro_of_processing/</guid>
      <description>

&lt;div style=&#34;text-align:right&#34;&gt;
情報工学科 2年
[毛利想一](https://sites.google.com/site/mokume1shin/home)
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;情報工学科の毛利想一（オンラインでは木目壱心として地味に活動してる）です。
ちょっとだけゲームを作ったりしてます。&lt;/p&gt;

&lt;p&gt;この記事では、私が愛用しているProcessingというプログラミング言語（及びそのエディタ）の基本的な使い方を説明したいと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;processingの概要&#34;&gt;Processingの概要&lt;/h2&gt;

&lt;p&gt;ダウンロードと起動にしばらく時間がかかるので、ここは後回しでもいいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MIT&lt;/strong&gt; で作られた。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Processingは、マサチューセッツ工科大学（MIT）のメディアラボで作られたJavaベースのプログラミング言語です。
ベースになったJava屋その他の言語 &lt;em&gt;(私はあんまり他にはやってないから何とも言えないが。)&lt;/em&gt; と比較しても、かなり簡単にプログラミングすることが可能になっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;奈良高専情報工学科の体験入学&lt;/strong&gt; でも使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;来た人もいるかもしれませんが、奈良高専情報工学科の体験入学でもProcessingを使用しました。もしそれをやったことがあるなら、下記の「動かす」ところまでは読み飛ばしてもいいと思います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;情報工学科生&lt;/strong&gt; ならスペルを覚えておこう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本題とは全く無関係ですが、専門教科の情報工学概論の後記中間テストあたりで &lt;strong&gt;CPU(Central Processing Unit)&lt;/strong&gt; のスペルを書くという問題が出ます。&lt;strong&gt;CPU&lt;/strong&gt; の &lt;strong&gt;P&lt;/strong&gt; はProcessingなので、覚えておいて損はないかと。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;processingのダウンロード方法&#34;&gt;Processingのダウンロード方法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Processing公式ページ &lt;a href=&#34;http://processing.org&#34;&gt;http://processing.org&lt;/a&gt; にアクセス&lt;/li&gt;
&lt;li&gt;ページ中央の、 &lt;strong&gt;Download Processing&lt;/strong&gt; をクリック&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No Donation&lt;/strong&gt; を選択し、最新版をDL（ちなみにこれを書いているときの最新版は3.2.3）
※別に寄付してもいいけど&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;processingの起動&#34;&gt;Processingの起動&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;processing.exe&lt;/strong&gt; をクリック&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;※環境によってはしばらく時間かかるけど我慢。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;こんなのが開くはず&lt;/p&gt;
&lt;/blockquote&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_start.png&#34; alt=&#34;processing_start.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;hr /&gt;

&lt;h2 id=&#34;初期設定をする&#34;&gt;初期設定をする&lt;/h2&gt;

&lt;p&gt;あくまでも見やすくするためですが、Processingの表示が日本語になるようにします。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ウィンドウ上部にある &lt;strong&gt;File&lt;/strong&gt; タブの中の、 &lt;strong&gt;Preferences&lt;/strong&gt; をクリックする。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Languages&lt;/strong&gt; が &lt;strong&gt;English&lt;/strong&gt; になっているのを &lt;strong&gt;日本語&lt;/strong&gt; に変える。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor and Console font&lt;/strong&gt; を &lt;strong&gt;MSゴシック&lt;/strong&gt; などの日本語フォントに変える。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor font size&lt;/strong&gt; や &lt;strong&gt;Console font size&lt;/strong&gt; は、適宜見やすいように変更する。&lt;/li&gt;
&lt;li&gt;Processing を再起動。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;プログラミングを始める&#34;&gt;プログラミングを始める&lt;/h2&gt;

&lt;p&gt;では、本題のプログラミングをやり始めよう。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;とりあえず動かす。&lt;/p&gt;

&lt;p&gt;Processingは、まったく何も書かなくても実行できます。（ここ、すごいところ）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;まったく何も書かない（エディタが真っ白な）状態で左上の再生ボタン(右向きの三角形)を押してみましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;灰色の画面が開くはずです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_null.png&#34; alt=&#34;processing_null&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;キーボードの確認&amp;amp;覚えておいてほしいこと。&lt;/p&gt;

&lt;p&gt;いよいよプログラムのコードを書くことになります。
その際に必要になってくるキーを確認しましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;セミコロン &lt;strong&gt;；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;キーボードのLの右隣にあります。
 このキーが存在しない場合や、キーボードのこのキーが死んでしまった場合は、この世界の終わりのようなことになります。
 Java,C言語などで共通して1文の終了を意味します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ダブルクォート &lt;strong&gt;&amp;ldquo;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文字列データ( &lt;em&gt;String&lt;/em&gt; )を囲むときに使います。
 &lt;em&gt;Shiftキー&lt;/em&gt; を押しながら2キーを押すことで出せます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;シングルクォート &lt;strong&gt;&amp;lsquo;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1文字データ( &lt;em&gt;char&lt;/em&gt; )を囲むときに使います。
 &lt;em&gt;Shiftキー&lt;/em&gt; を押しながら7キーを押すことで出せます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コメント文について &lt;strong&gt;//&lt;/strong&gt; or. &lt;strong&gt;/* */&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これからサンプルコードとして書かれていく枠の中に、//や/*などが出現しますが、それらはプログラムとしては実行されなくなります。
 これを見て写す場合は、書く必要性はありません。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;画面サイズを調節する。&lt;/p&gt;

&lt;p&gt;先ほどの画面サイズでは、あまりにも小さすぎるので、大きさを調節しましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;画面サイズを調節するには、size &lt;strong&gt;関数&lt;/strong&gt; を使います。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;書き方は、size(横の長さ,縦の長さ);のようにします。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;とりあえずそのまま写してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_size.pde&#34;&gt;size(500,300);
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_size.png&#34; alt=&#34;processing_size.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;次に適当に値を変化させてみましょう。&lt;/p&gt;

&lt;p&gt;※0とか10000の値を入れた場合は実行できないので注意。&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ところで、唐突に &lt;strong&gt;関数&lt;/strong&gt; という言葉が出てきました。
関数というのは、カッコの中に値（数値とか文字列とか）を入れることで、関数の内容に対応した結果が得られるもののことです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;図形を書く&lt;/p&gt;

&lt;p&gt;では、いよいよProcessingで図形を描いてみましょう。&lt;/p&gt;

&lt;p&gt;ですが、あんまりたくさん紹介しても仕方がないので、よく使うものに絞って説明します。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;座標について&lt;/p&gt;

&lt;p&gt;ですがまず、プログラムで図形を描く注意点として、座標（図形の位置の設定）について説明しておきます。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_matrix.png&#34; alt=&#34;processing_matrix&#34; width=&#34;400&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上図(左)のように、数学(Mathmatics)
では、グラフのX,Yが正の領域は左下を原点として右上に広がっていきます。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;それに対して、上図(右)のProcessingを含むすべてのプログラムでは、左上を原点として右下に向かって領域が広がっていきます。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;point&lt;/p&gt;

&lt;p&gt;point関数は、点を描きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_point.pde&#34;&gt;  size(480,120);
  point(240,60);
  //point(X座標,Y座標);
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_point.png&#34; alt=&#34;processing_point.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;真ん中に点が出てくるはず。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;line&lt;/p&gt;

&lt;p&gt;line関数は、線を描きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_line.pde&#34;&gt;  size(480,120);
  line(20,20,460,100);
  //line(始点X座標,始点Y座標,終点X座標,終点Y座標);
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_line.png&#34; alt=&#34;processing_line&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rect&lt;/p&gt;

&lt;p&gt;rect関数は、長方形を描きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_rect.pde&#34;&gt;  size(480,120);
  rect(20,20,440,80);
  //rect(左上のX座標,左上のY座標,横の長さ,縦の長さ);
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_rect.png&#34; alt=&#34;processing_line&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ellipse&lt;/p&gt;

&lt;p&gt;ellipse関数は、楕円を描きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_ellipse.pde&#34;&gt;  size(480,120);
  ellipse(240,60,100,100);
  //ellipse(中心のX座標,中心のY座標,X軸方向の直径,Y軸方向の直径);
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_ellipse.png&#34; alt=&#34;processing_ellipse&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;綴りがややこしいですが、円を描くことがよくあるので覚えておくとよいです。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vertex&lt;/p&gt;

&lt;p&gt;vertex関数は、多角形を描くことができます。&lt;/p&gt;

&lt;p&gt;beginShape()からendShape()までが1つの図形です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_vertex.pde&#34;&gt;  size(480,120);
  beginShape(); //図形を描き始める
  vertex(240,20); //頂点一つ一つの座標
  vertex(120,100);
  vertex(360,100);
  endShape(CLOSE);  //図形を描き終わる
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_vertex.png&#34; alt=&#34;vertex&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;endShape()の中の &lt;strong&gt;CLOSE&lt;/strong&gt; というのは、図形の周りを囲んでいる線の最初と最後をつなぐという意味です。
  試しに消してみるとよく分かります。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;text&lt;/p&gt;

&lt;p&gt;text関数は文章を書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_text.pde&#34;&gt;  size(480,120);
  textSize(50); //文字の大きさを指定
  text(&amp;quot;Hello Joken World!&amp;quot;,20,80); //文字列を描画
  //text(表示する内容,表示座標X,表示座標Y);
  //表示座標は文字列の左下が基準
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_text.png&#34; alt=&#34;Hello_Joken_World!&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;色を付ける。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;色について&lt;/p&gt;

&lt;p&gt;Processingで色を使う時は、光の三原色(RGB)と透明度(Alpha)で表されます。&lt;/p&gt;

&lt;p&gt;入力する値は &lt;strong&gt;0~255&lt;/strong&gt; の間で、値の入力の仕方はいろいろあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sample_color.pde&#34;&gt;  fill(255);          //グレースケール（白～黒の間）で色指定。現在は白。
  fill(0,100);        //グレースケール＋透明度で色指定。現在は半透明な黒。
  fill(255,0,255);    //RGBで色指定。現在は紫（結構どぎつい）。
  fill(0,255,0,100);  //RGB+透明度で色指定。現在は半透明の緑。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;background&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_background.pde&#34;&gt;  size(480,120);
  background(200,255,200);
  //背景色。ちなみに今までの背景色はbackground(204);
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_background.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;薄い青が表示されているはずです。
  薄すぎて見えないかも。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fill / noFill&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_fill.pde&#34;&gt;  size(480,120);
  fill(100,255,100);
  //図形の塗色の設定。指定した後、再指定するまでのすべての図形に適用。
  ellipse(120,60,100,100);  //左の円
  rect(240,10,100,100);     //真ん中の四角
  fill(255,100,100);
  rect(360,50,50,50);       //右の四角
  noFill();                 //図形の塗色を無しに。
  ellipse(400,0,50,50);     //上の円(透明)
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_fill.png&#34; alt=&#34;procossing_fill&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;stroke / noStroke&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_stroke.pde&#34;&gt;  size(480,120);
  //図形の縁の色の指定。指定した後、再指定するまですべての図形に適用。
  stroke(255,100,255);
  line(50,10,50,110);   //左の線
  ellipse(240,60,100,100);  //真ん中の円
  noStroke(); //図形の縁を無くす。
  rect(300,10,100,100);   //右の四角
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_stroke.png&#34; alt=&#34;processing_stroke&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strokeWeight&lt;/p&gt;

&lt;p&gt;線の太さを指定します。
  通常は1です。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;問題&#34;&gt;問題&lt;/h4&gt;

&lt;p&gt;下のような図形を描いてください。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/image_test.png&#34; alt=&#34;processing_image_test&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;変数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;変数というのは、数学でいうところのXとかYみたいなものです。
いろいろな値を入れて保存し、どこかで呼び出すのに使います。&lt;/li&gt;
&lt;li&gt;次にあげる4つは、変数の名前を決める時に、その変数がどのような値を入れるのかをコンピュータに分かるようにするためのものです。&lt;/li&gt;
&lt;li&gt;すべてのプログラムで必須なので、これを習得することは必須です。
とは言いつつも、内容自体はかなりシンプルなので、あまり複雑にならないように書いておきます。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;int
整数値を扱う時に使用します。&lt;/li&gt;
&lt;li&gt;float
小数値を扱う時に使用します。
一番これをよく使う気がする。&lt;/li&gt;
&lt;li&gt;String
文字列を扱う時に使用します。&lt;/li&gt;
&lt;li&gt;char
半角一文字を扱う時に使用します。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_variables.pde&#34;&gt;  int r;  //変数の宣言(名前を付ける)　整数値
  r=70;   //変数に値を代入
  ellipse(50,50,r,r);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四則演算&lt;/p&gt;

&lt;p&gt;四則演算とは、加減乗除の計算のことで、+(加),-(減),*(乗),/(除)などの記号を用いるのが一般的です。
Processingも同じなので、これからプログラミングの勉強をするという時に少しは役に立ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_calc.pde&#34;&gt;int x=10;
//下の黒い部分に数字が表示される。
println(x);   //10
println(x+2); //10 + 2 = 12
println(x-3); //10 - 3 = 7
println(x*3); //x × 3 = 30
println(x/2); //x ÷ 2 ＝ 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計算して値を代入する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_calc2.pde&#34;&gt;int x=10;
x=x+2;  //xにx+2を「代入」(「等しい」ではありません)
println(x); //12
x=x*3;  //xにx*3を代入
println(x); //36
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;x=2&lt;/strong&gt; は &lt;strong&gt;x+=2&lt;/strong&gt; と書いても同じ意味です。
同様に、&lt;strong&gt;x=x*3&lt;/strong&gt; は &lt;strong&gt;x * =3&lt;/strong&gt; と書いても同じ意味です。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;問題-1&#34;&gt;問題&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;xに3を代入して、xに5を足して9倍、7を引いた値を出してください。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;動かす&lt;/p&gt;

&lt;p&gt;いよいよProcessingでアニメーションを作ります。&lt;/p&gt;

&lt;p&gt;ここで扱うアニメーションは、1秒間に60回ほど図形を描き直すことによって成り立っています。
その1回の上書きをフレームと呼びます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;アニメーション

&lt;ol&gt;
&lt;li&gt;setup関数
起動時に1回だけ実行される部分です。&lt;/li&gt;
&lt;li&gt;draw関数
1秒間に60回ほど実行される部分です。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_animation.pde&#34;&gt;  int x=50;
  void setup(){
         size(480,120);
         background(255);
  }
  void draw(){
         x+=5;
         ellipse(x,60,100,100);
  }
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_animation.png&#34; alt=&#34;processing_animation&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;円が右へ動けば正解です。&lt;/p&gt;

&lt;p&gt;残像を残したくない場合は &lt;strong&gt;x+=10;&lt;/strong&gt; の前に &lt;strong&gt;background(255);&lt;/strong&gt; を書き足してください。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;操作&lt;/p&gt;

&lt;p&gt;こんなふうにプログラムを書き足して、何かが動く様子を眺めるのもいいのですが、それではゲームになりません。&lt;/p&gt;

&lt;p&gt;マウスで操作できるようにしてみましょう。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mouseX
マウスの画面内のX座標。&lt;/li&gt;
&lt;li&gt;mouseY
マウスの画面内のY座標。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_mouse.pde&#34;&gt;  void setup(){
       size(480,480);
  }
  void draw(){
       ellipse(mouseX,mouseY,100,100);
  }
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_mouse.png&#34; alt=&#34;processing_mouse&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;さあ、マウスで絵が描けるようになりました。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;条件分岐&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;条件分岐は、変数がどのような状態にあるかによって、その次に実行されるプログラムを切り替えるために使われます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_if.pde&#34;&gt;  void setup(){
       size(480,480);
  }
  void draw(){
       background(204);
       if(dist(width/2,height/2,mouseX,mouseY)&amp;lt;50){
         fill(0);
       }else{
         fill(255);
       }
       ellipse(width/2,height/2,100,100);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マウスが円の上にないとき
  
&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_if1.png&#34; alt=&#34;processing_if1&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;マウスが円の上にあるとき
  
&lt;figure &gt;
    
        &lt;img src=&#34;https://kyumina.github.io/jokenoffline2017/images/processing_if2.png&#34; alt=&#34;processing_if2&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;なんかいろいろとややこしいですが、1つ1つ説明していきましょう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;width&lt;/strong&gt; は画面の横の長さ、&lt;strong&gt;height&lt;/strong&gt; は画面の縦の長さです。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;つまり、円の中心座標が &lt;strong&gt;(width/2,height/2)&lt;/strong&gt; となっているので、画面の真ん中に円を表示するという事になります。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;size()関数の中の値を変えても、画面の真ん中に表示されます。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dist関数は二点間の距離を測ります。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;つまり、 &lt;strong&gt;画面中央(円の中心座標)&lt;/strong&gt; から、あなたのマウスの座標までの距離を測っています。&lt;/p&gt;

&lt;p&gt;その距離が円の半径よりも小さい &lt;strong&gt;(&amp;lt;50)&lt;/strong&gt; 場合は円の色を黒くするという事になっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if文は、 &lt;strong&gt;if(条件){}&lt;/strong&gt; と書き、条件が成り立つとき、中カッコの中 &lt;strong&gt;{}&lt;/strong&gt; の文章が実行されます。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;そのあとの &lt;strong&gt;else&lt;/strong&gt; という部分は、if分の条件が成り立たなかったときに実行されます。
つまり、円を白くしています。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if文の判定に使われる記号&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_if_example.pde&#34;&gt;  a==b  aとbが等しいとき
  &amp;gt;     bよりaが大きいとき
  &amp;lt;     bよりaが小さいとき
  &amp;gt;=    aがb以上
  &amp;lt;=    aがb以下
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;いくつかの判定を重ねるときに使う記号&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-processing_if_example2.pde&#34;&gt;  if(a==b || a==c){
      //aがbと等しく、または、aがcと等しいときに実行される。
  }
  if(a==b &amp;amp;&amp;amp; a==c){
      //aがbと等しく、かつ、aがcと等しいときに実行される。
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;マウスが押されているかどうか判定するときは、&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;  if(mousePressed){
      //なんたらかんたら
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書く。&lt;/p&gt;

&lt;p&gt;### 問題&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;マウスが円の中に入っていることを判定するプログラムを、 &lt;strong&gt;円の中でクリック&lt;/strong&gt; している事を判定するプログラムに変えてください。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(HINT)&lt;/em&gt; &amp;amp;&amp;amp;とmousePressedを使う。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;p&gt;ここに書いたのは、あくまでも基本的なことで、これだけで何か作れるかどうかはまた別の話です。
まだ、for文、関数、配列、classなどをやらないといけないのですが、説明が難しい&amp;amp;めんどくさいので、そこは自学自習をお勧めします。
というかこんな文章を読まなくても、「Processingをはじめよう」という良書がありますので、それを読めば大体のことができるようになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;おまけ&#34;&gt;おまけ&lt;/h2&gt;

&lt;p&gt;この分かりにくい文章を書いた私は、Processingを使ってちょっとしたゲームを作っています。
ちょっとでも習得の助けになればいいと思っています。&lt;/p&gt;

&lt;p&gt;P.B.B.  &lt;a href=&#34;http://www.freem.ne.jp/win/game/12019&#34;&gt;http://www.freem.ne.jp/win/game/12019&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;P.C.C.  &lt;a href=&#34;http://www.freem.ne.jp/win/game/12857&#34;&gt;http://www.freem.ne.jp/win/game/12857&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>東方弾幕風で弾幕STGを作った話</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/make_danmaku/</link>
      <pubDate>Fri, 07 Apr 2017 10:43:02 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/make_danmaku/</guid>
      <description>

&lt;p&gt;制作期間：2ヵ月&lt;/p&gt;

&lt;p&gt;使用ソフト：東方弾幕風&lt;/p&gt;

&lt;p&gt;東方弾幕風ダウンロード元：
&lt;a href=&#34;http://www.geocities.co.jp/SiliconValley-Oakland/9951/products/th_dnh.html&#34;&gt;http://www.geocities.co.jp/SiliconValley-Oakland/9951/products/th_dnh.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;※Windows10では動かないこともあるので動かなかったときは東方弾幕風を右クリックし、
プロパティ＞互換性に移動し互換モードの互換モードでこのプログラムを実行するにチェックを入れ、
下の欄でWindowsXPを選択し適用し実行してください。
それでも動かなかった場合、管理者として実行を選択し実行してください。&lt;/p&gt;

&lt;h2 id=&#34;解説&#34;&gt;解説&lt;/h2&gt;

&lt;p&gt;ここでは、東方弾幕風についてスクリプトの基本的な書き方について説明していきます。
東方弾幕風の基本操作につては東方弾幕風ダウンロード元のヘルプ関連サイトを参照してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 東方弾幕風
# Title[弾幕の名前]
# Text[弾幕の説明]
# ScriptVersion[2]

script_enemy_main {
敵の動き
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;東方弾幕風では東方弾幕風のスクリプトを認識するためにスクリプトの一行目に「#東方弾幕風」と書きます。
書かなかった場合は、スクリプトとして認識しないようになるので注意してください。
２行目、３行目は書かなくても問題はありません。
４行目の「# ScriptVersion[2]」はスクリプトのバージョンを表しています。
そして、６行目の「script_enemy_main{ }」の{ }の中に敵の動作に関するスクリプトを書いていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#東方弾幕風
#Title[弾幕の名前]
#Text[弾幕の説明]
#ScriptVersion[2]

script_enemy_main{
  let imgBoss = &#39;画像パス&#39;;
  let flame = 0;
  let angleBase = 90;

  @Initialize{
    SetX(GetCenterX); //敵の表示位置の設定(中心のX座標)
    SetY(GetClipMinY + 120); //敵の表示位置の設定(上端のY座標から120進んだところ)
    SetLife(2000); //敵の体力の設定(2000)

    LoadGraphic(imgBoss); //敵の画像の読み込み(画像パス)
    SetTexture(imgBoss); //敵の画像の描画(画像パス)
    SetGraphicRect(0, 0, 63, 63); //画像の描画範囲
  }

  @MainLoop{
    SetCollisionA(GetX, GetY, 24); //自弾と当たった時の敵の当たり判定(敵のX座標, 敵のY座標, 半径)
    SetCollisionB(GetX, GetY, 24); //自機と当たったときの敵の当たり判定(敵のX座標, 敵のY座標, 半径)

    frame++; //フレーム毎にframeに1を足す
    if(frame % 30 == 0) { //frameが30で割り切れる時だけ実行される
      let angle = angleBase - 10; //angleの宣言
      loop(3) { //3回繰り返す
        CreateShot01(GetX, GetY, 1, angle, YELLOW01, 0); //弾を生成する(弾を発射する座(X座標), 標弾を発射する座標(Y座標), 速度, 角度, 画像, 弾が実態するまでの時間)
        angle += 10; //angleに10を足す
      }
      angleBase += 8; //angleBaseに8を足す
    }
  }

  @DrawLoop{
    DrawGraphic(GetX, GetY); //設定した情報で描画を行う(敵のX座標, 敵のY座標)
  }

  @Finalize{
    DeleteGraphic(imgBoss); //指定した画像の描画を止める
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初の7行目ではC言語のように変数を宣言しています。
変数の中は敵を描画するための画像のパスを入力してあります。
変数を宣言することにより入力ミスを防ぐことができ、画像のパスのような面倒な入力を何度もしなくてもよくなります。&lt;/p&gt;

&lt;p&gt;9行目では時間的な要素を追加するためにframeという変数を作り0を代入しています。&lt;/p&gt;

&lt;p&gt;10行目では角度の基準を作るためにangleBaseという変数を作り90を代入しています。&lt;/p&gt;

&lt;p&gt;「@Initialize{ }」の{ }の中には敵が出現したとき一度だけ実行されるスクリプトを書きます。&lt;/p&gt;

&lt;p&gt;この中の最初の３行で敵の画像の描画位置と敵の体力を設定しています。&lt;/p&gt;

&lt;p&gt;あとの３行で画像をパスから読み込み表示範囲を設定し表示の開始をしています。&lt;/p&gt;

&lt;p&gt;「@MainLoop{ }」の{ }の中には敵のライフが0になるまで繰り返すスクリプトを書きます。
※１フレームごとに繰り返されます。
この中の最初の２行で敵の当たり判定を設定しています。&lt;/p&gt;

&lt;p&gt;「frame++」はそのプログラムが実行されるたびにframeに+1されることを表しています。
つまり、フレーム毎にframeに+1されていきます。&lt;/p&gt;

&lt;p&gt;ifの中はframeが30で割り切れるときだけ実行されるようになっています。&lt;/p&gt;

&lt;p&gt;ここで、angleを宣言し弾の発射角を決定します。&lt;/p&gt;

&lt;p&gt;次に弾を( )の中の通りに生成しangleに10をangleBaseに8を足します。&lt;/p&gt;

&lt;p&gt;「@DrawLoop{ }」の{ }の中は描画ループについてを書きます。
※１フレームごとに繰り返されます。
この中では敵を描画し続けるように設定しています。&lt;/p&gt;

&lt;p&gt;「@Finalize{ }」の{ }の中には敵のライフが0になったときに一回だけ実行されるスクリプトを書きます。
ここでは、体力が0になったとき敵を消すよう設定しています。&lt;/p&gt;

&lt;p&gt;そして、これを実行すると敵が描画され3wayの弾を回転しながら30フレームづつ発射していきます。&lt;/p&gt;

&lt;h2 id=&#34;反省点&#34;&gt;反省点&lt;/h2&gt;

&lt;p&gt;・技の種類が少なかった&lt;/p&gt;

&lt;p&gt;・ソースコードの管理が全くできていなかった&lt;/p&gt;

&lt;p&gt;・人材管理が行き届いていなかった&lt;/p&gt;

&lt;h2 id=&#34;jokenに入って&#34;&gt;Jokenに入って&lt;/h2&gt;

&lt;p&gt;Jokenに入って楽しと感じたところは先輩との上下関係が厳しくないので話しやすく、
自分の作りたいものや面白そうなものを先輩と相談しながら作れるところです。　　&lt;/p&gt;

&lt;p&gt;特に、U-22や高専プロコンの事などについて考えて作るのは楽しいです。
部活としてはかなり緩くやっているので初めて入った人も比較的早くなじめるかと思います。
何か作りたいと考えている人はぜひjokenの部室にお立ち寄りください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>プログラムとpam,spam</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/programing_hoge/</link>
      <pubDate>Fri, 07 Apr 2017 09:58:56 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/programing_hoge/</guid>
      <description>

&lt;h1 id=&#34;初めに&#34;&gt;初めに&lt;/h1&gt;

&lt;p&gt;今年から2Iのteikuと申します．ご入学おめでとうございます．
今回このような場を設けていただいたので，私は予備知識として持っていてほしいことについて書かせていただきます．
特に1，3は軽く知っていると便利ですし、2はpython(後述)の環境さえあれば順を追ってある程度のことができます．
また，この文章は実力のない初心者がネットの記事に頼って作成したものです．ご了承ください.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;目次&#34;&gt;目次&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;プログラミング言語の特徴&lt;/li&gt;
&lt;li&gt;プログラミングの順次処理について&lt;/li&gt;
&lt;li&gt;GUIとCUIについて&lt;/li&gt;
&lt;li&gt;メタ構文変数について&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;1-プログラミング言語の特徴&#34;&gt;1. プログラミング言語の特徴&lt;/h1&gt;

&lt;h2 id=&#34;1-java&#34;&gt;1. Java&lt;/h2&gt;

&lt;p&gt;現在最も求人の多い言語．すなわち現代企業で最も需要のある言語と言える．
奈良高専の情報工学科が習うのもJavaである．広い用途に使用でき，オブジェクト指向の代表ともいえる．
難易度は高すぎはせず, 実行速度は速め.&lt;/p&gt;

&lt;h2 id=&#34;2-ruby&#34;&gt;2. Ruby&lt;/h2&gt;

&lt;p&gt;習得難易度が高くなく，自由度の高いプログラミング言語．開発者が日本人なので非常にとっつきやすい．実行速度が遅めなのが難点．&lt;/p&gt;

&lt;h2 id=&#34;3-javascript&#34;&gt;3. JavaScript&lt;/h2&gt;

&lt;p&gt;Javaと名前は似ているが，名前だけあやかったようなもので全く関係がない．Web上での使用が一般的なので用途は限られるが，
実行速度は非常に速い．htmlやPHP，CSSと合わせて覚えている人が多い印象．&lt;/p&gt;

&lt;h2 id=&#34;4-c&#34;&gt;4. C&lt;/h2&gt;

&lt;p&gt;全てのプログラミング言語の基礎ともいえる言語．OS等も全てCで書かれている．基礎となっているだけあって，とてつもなく速い．習得にかかる時間が非常に長い．&lt;/p&gt;

&lt;h2 id=&#34;5-c&#34;&gt;5. C++&lt;/h2&gt;

&lt;p&gt;Cにあらゆる機能を追加した言語．Cでも時間がかかるのに，さらに機能を追加しているということでもうお察しだろう．&lt;/p&gt;

&lt;h2 id=&#34;6-c&#34;&gt;6. C&lt;/h2&gt;

&lt;p&gt;名前からはC言語を連想するが，Javaがベース．JavaScriptのような卑怯さを感じるネーミングセンス．
GUIアプリを書くときによく使われる．Javaよりも早い．VisualStudioの恩恵を強く受けるが，Linuxでは使えない．&lt;/p&gt;

&lt;h2 id=&#34;7-python&#34;&gt;7. Python&lt;/h2&gt;

&lt;p&gt;非常に簡潔に多くのことをできる万能君．初心者でもまとまりがわかりやすいからか，jokenでは最近推奨されている．
学習難度が高くないこともそれを後押ししているのだろう．最近それなりに需要が高まってはいるが，求人数はいまだに少ない.&lt;/p&gt;

&lt;h1 id=&#34;2-プログラムの順序処理について&#34;&gt;2. プログラムの順序処理について&lt;/h1&gt;

&lt;p&gt;プログラムには，実行される順序というものが存在する．当然，あっちへ行ったりこっちへ行ったりすることはない．
具体例を挙げてみよう．今回使用するプログラミング言語は，joken (情報処理研究会のこと) で最初にお奨めされるpython(3系統)とする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-hello.py&#34;&gt;print (“Hello world!”)
print (“Welcome to joken!”)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“print”とは，「~という文字を出力しなさい」という命令である．
この場合，上から順番に処理されるため実行(命令をさせること)結果は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello world!
Welcome to joken!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる．このように，上から下へ順番にプログラムが処理されていくことを「順次」という．&lt;/p&gt;

&lt;p&gt;次から少し複雑になる，“if文”などと呼ばれるものを使うのだが，意味はそのままで，「もし~ならば，…である」となる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bunki.py&#34;&gt;x=100
if x&amp;gt;0:
    print(&amp;quot;hoge&amp;quot;)
else:
    print(&amp;quot;fuga&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“else”すなわち「他に」．これは，「もしxが100以上なら」「”hoge”と出力しなさい」「それ以外なら」「”fuga”と出力しなさい」というプログラムである．
この場合，x&amp;gt;0に当てはまるので，結果は”hoge”のみとなる．”else”以下の内容は無視される.
このように，条件により命令が分かれ，当てはまらないものは無視される処理のことを「分岐」という．“else”と”if”を組み合わせた”elif”というものもあるが割愛する．&lt;/p&gt;

&lt;p&gt;最後は”while文”を説明する．「~する間」という意味だが，pythonでは 「~が真である間」という命令となる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kurikaeshi.py&#34;&gt;x=10
while x==10:
    print(&amp;quot;hoge&amp;quot;)
x+=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムは，「xが10と等しい間，」「“hoge”と出力しなさい，xに1を加算しなさい」と解釈できるのだが，“==”，”+=” というのは見慣れないと思う．
“==” とは「右辺と左辺を比較して等しい」という意味で，“+=” とは「右辺んの数だけ加算したものを左辺に代入する」という意味である．今回の場合，
右辺は1なので「xに+1した値をxとする」，よってwhileの条件が当てはまらなくなる．もし仮に”x += 1” がなければ，永遠に”hoge”が出力されることとなる.
例えば，昔のゲームでよくある「~に10回話しかけるとフラグが立つ」というものを作るなら，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tencount.py&#34;&gt;x=0
while x &amp;gt;=10:
    print (“ここはjokenの村です”)
    x+=1
    break
else:
    print (“よく私が魔王だと見切ったな小僧”)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる．“break”というのは，“while文”等のループから脱出するというものである．このように，指定された条件に当てはまるまで繰り返される処理のことを「反復」という．&lt;/p&gt;

&lt;p&gt;ある程度は理解していただけただろうか．見ているだけではわからないことも，実際にプログラムを組んでみるとわかることはたくさんある．
百聞は一見に如かず，という言葉そのものである．殆どのプログラマが，「見よう見まねで組んでみるのが一番手っ取り早い」と言うだろう．
最初は本当にしょうものないことしかできないが，やっていくに従ってできることが増えていくのがプログラムの面白味だ．
しかし，理解に時間がかかるものなので気長にのんびりやっていくくらいが一番いいと思う．
実際，私も大した実力など持っていないが，プログラミングの勉強に面白味は感じている．&lt;/p&gt;

&lt;p&gt;余談ではあるが，プログラミングの勉強には幾つか方法がある．よくあるのが「本を読む」「人に聞く」「ネットで調べる」の三つなのだが，私が最もおすすめするのは「本を読む」ことだ．
「人に聞く」は，自分のペースでやりにくいことが多い．どうしても解らない時は人に聞くのが一番なのだが，全て人に聞いて進めていくとなかなか時間もかかってしまう．
また，「ネットで調べる」というのは言葉がわかりにくい場合が多いのでお勧めしがたい．ただし，動画をみるのは良い方法だとは思う．
時間はかかるが，解りやすい説明が多く，また何度も聞き直しができるため人に聞けない，でもわからない場合には便利である．&lt;/p&gt;

&lt;h1 id=&#34;3-cuiとguiについて&#34;&gt;3. CUIとGUIについて&lt;/h1&gt;

&lt;p&gt;普段，ネット検索する時，当たり前のようにブラウザのアイコンをクリックして起動し，当たり前のようにリンクをクリックする．
直感的な操作が可能なため非常に便利である．これは，GUI(Graphical User Interface)というもので，
ウィンドウ，アイコン，ボタン等総てがそうである．GUIが発明される前に主流であったのがCUI(Character User Interface)で，こちらは文字のみで表現されているものだ．
例えば，GUIではドラッグ&amp;amp;ドロップのみでできるファイルの操作もいちいちフォルダの指定を文字でしなければならない．また，そのような操作をするためのコマンドも覚える必要がある．&lt;/p&gt;

&lt;p&gt;　最近ではCUIはLinuxを扱う人以外に使われることは非常に少ない．windowsではコマンドプロンプトやwindows power shellがそれにあたるのだが，
後者に至っては存在すら知らない人が大多数を占めるのではないだろうか．文字だけなので非常にわかりにくく，とっつきにくいため避けがちになってしまうが，
プログラムをしていくにつれて徐々に必要性が高まってくるため使えたほうが圧倒的に有利であることに間違いはない．少しずつ慣れていくのがいいのではないかと思う．&lt;/p&gt;

&lt;h1 id=&#34;4-メタ構文変数について&#34;&gt;4. メタ構文変数について&lt;/h1&gt;

&lt;p&gt;日本でよく使われるのは”hoge”，“fuga”，”piyo”であるのに対し，海外では”foo”，”bar”，”baz”等が多く使われる．
また，朝食シリーズなども存在し，“spam”，”ham”，”eggs” くらいが一般的．名前シリーズ等ほかにも幾つも存在する．
だが，そもそもこれらはどのような意味を持つのか．正解は「意味がない」のである．意味がないことに意味があるのである．
何を言っているのかわからないと思うが，わかりやすく説明すると「取り敢えず名前を付ける目的の時に用いる記号」だ．
数学の図形の問題を解こうと思ったとき，わからない辺の長さを適当に「x」だとか，「a」だとかにした覚えはないだろう．
それと同じで，取り敢えず変数や出力するものに”hoge”やら”foo”やらを使うのだ．&lt;/p&gt;

&lt;p&gt;メタ構文変数を使うメリットは当然存在する．誰が見ても「意味がない」という共通認識を持っていることだ．
例えば，複数人で一つのプログラムを組んでいたとする．あなたが仮に適当な変数名として”metric”と頭に思い浮かんだのでつけてプログラムを組んでいたとしよう．
そのプログラムをほかの人が見た時に「metric?何の意味があるんだ?」と戸惑ってしまうことがある．
そのようなことを避けるため”hoge”とつけてやることで混乱を防ぐことができる．また，後々いい変数名が決まった時にメタ構文変数だと一目見てわかるため変更がしやすいのも特徴である．
一つ注意点として，語呂の良さ日頃からつい「ほげ」と口にしてしまうことがある．急にほげほげ言ってしまう人にはならないようにしよう．&lt;/p&gt;

&lt;h1 id=&#34;おまけ-jokenにいた感想&#34;&gt;おまけ jokenにいた感想&lt;/h1&gt;

&lt;p&gt;　非常に居心地もいいうえ，環境も揃っています．ただ，基本的に個人作業なのでやる気がない人(まさに私)は苦労を強いられますね．
あと夏は尋常じゃないくらいに湿度が高まり，冬は尋常じゃないくらいに冷え込みます．
湿度が高いのが苦手(まさに私)，気温が低いのが苦手(まさに私)には厳しい面もあります．
そういうときはおうちに引きこもって(まさに私)作業するのも一つの手です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JokenOfflineを電子化した</title>
      <link>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/joken-offline-online/</link>
      <pubDate>Fri, 07 Apr 2017 01:19:35 +0900</pubDate>
      
      <guid>https://kyumina.github.io/jokenoffline2017/archives/2017/04/07/joken-offline-online/</guid>
      <description>&lt;p&gt;JokenOfflineをとうとう電子化してしまった。本当は部活紹介前で執行部が開かず、今年落としかけたのは内緒。offlineなのかonlineなのかわかんねぇな。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>